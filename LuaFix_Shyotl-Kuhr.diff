diff -daur indra/develop.py Update/develop.py
--- indra/develop.py	2009-12-26 18:47:03.722874400 -0600
+++ Update/develop.py	2009-12-28 22:58:18.287010500 -0600
@@ -45,7 +45,6 @@
 class CommandError(Exception):
     pass
 
-
 def mkdir(path):
     try:
         os.mkdir(path)
@@ -473,6 +472,12 @@
         super(WindowsSetup, self).__init__()
         self._generator = None
         self.incredibuild = False
+        import struct
+        if struct.calcsize("P") > 4:        
+        	print "AMD64 Python executable detected. Redirecting registry lookup"
+        	self.wow64path = 'WOW6432node\\'
+        else:
+        	self.wow64path = ''
 
     def _get_generator(self):
         if self._generator is None:
@@ -527,8 +532,8 @@
         gen = gen.lower()
         try:
             import _winreg
-            key_str = (r'SOFTWARE\Microsoft\VisualStudio\%s\Setup\VS' %
-                       self.gens[gen]['ver'])
+            key_str = (r'SOFTWARE\%sMicrosoft\VisualStudio\%s\Setup\VS' %
+                       (self.wow64path,self.gens[gen]['ver']))
             value_str = (r'EnvironmentDirectory')
             print ('Reading VS environment from HKEY_LOCAL_MACHINE\%s\%s' %
                    (key_str, value_str))
@@ -542,15 +547,15 @@
         except WindowsError, err:
             print >> sys.stderr, "Didn't find ", self.gens[gen]['gen']
             return ''
-
+        
     def find_visual_studio_express(self, gen=None):
         if gen is None:
             gen = self._generator
         gen = gen.lower()
         try:
             import _winreg
-            key_str = (r'SOFTWARE\Microsoft\VCEXpress\%s\Setup\VC' %
-                       self.gens[gen]['ver'])
+            key_str = (r'SOFTWARE\%sMicrosoft\VCEXpress\%s\Setup\VC' %
+                       (self.wow64path,self.gens[gen]['ver']))
             value_str = (r'ProductDir')
             print ('Reading VS environment from HKEY_LOCAL_MACHINE\%s\%s' %
                    (key_str, value_str))
diff -daur indra/newview/flexconsole.cpp Update/newview/flexconsole.cpp
--- indra/newview/flexconsole.cpp	2009-12-26 16:57:39.770437800 -0600
+++ Update/newview/flexconsole.cpp	2009-12-28 22:35:44.997606800 -0600
@@ -15,33 +15,34 @@
 
 LLFloaterLuaConsole::~LLFloaterLuaConsole()
 {
-        sInstance = NULL;
+	sInstance = NULL;
 }
 
 LLFloaterLuaConsole* LLFloaterLuaConsole::getInstance()
 {
-        if(!sInstance) {
-                sInstance = new LLFloaterLuaConsole();
-                LLUICtrlFactory::getInstance()->buildFloater(sInstance, "floater_lua_console.xml");
-        }
-        return sInstance;
+	if(!sInstance) 
+	{
+		sInstance = new LLFloaterLuaConsole();
+		LLUICtrlFactory::getInstance()->buildFloater(sInstance, "floater_lua_console.xml");
+	}
+	return sInstance;
 }
 
 void LLFloaterLuaConsole::show(void*)
 {
-        getInstance()->open();
+	getInstance()->open();
 }
 
 void LLFloaterLuaConsole::toggle(void*)
 {
-        if(isVisible())
-        {
-                sInstance->setVisible(FALSE);
-        }
-        else
-        {
-                show(NULL);
-        }
+	if(isVisible())
+	{
+		sInstance->setVisible(FALSE);
+	}
+	else
+	{
+		show(NULL);
+	}
 }
 
 void LLFloaterLuaConsole::onClose(bool app_quitting)
@@ -51,74 +52,101 @@
 
 BOOL LLFloaterLuaConsole::postBuild()
 {
-        childSetAction("Send", onClickSend, this);
-        childSetAction("Clear", onClickClear, this);
-        childSetAction("Abort", onClickAbort, this);
-        childSetAction("Reset", onClickReset, this);
-
-        //childDisable("Send");
-        LLButton * sendp = getChild<LLButton>("Send");
-        LLPanel * luap = getChild<LLPanel>("lua_panel");
-        if(sendp && luap)
-        {
-                luap->setDefaultBtn(sendp);
-        }
+	childSetAction("Send", onClickSend, this);
+	childSetAction("Clear", onClickClear, this);
+	childSetAction("Abort", onClickAbort, this);
+	childSetAction("Reset", onClickReset, this);
 
-        LLLineEditor * editorp = getChild<LLLineEditor>("Lua Editor", TRUE);
-        if(editorp)
-        {
-                editorp->setCommitOnFocusLost(FALSE);
-                editorp->setRevertOnEsc(FALSE);
-                editorp->setEnableLineHistory(TRUE);
-        }
+	//childDisable("Send");
+	LLButton * sendp = getChild<LLButton>("Send");
+	LLPanel * luap = getChild<LLPanel>("lua_panel");
+	if(sendp && luap)
+	{
+		luap->setDefaultBtn(sendp);
+	}
 
-        return TRUE;
+	LLLineEditor * editorp = getChild<LLLineEditor>("Lua Editor", TRUE);
+	if(editorp)
+	{
+		editorp->setCommitOnFocusLost(FALSE);
+		editorp->setRevertOnEsc(FALSE);
+		editorp->setEnableLineHistory(TRUE);
+		editorp->setFocusReceivedCallback( &onInputEditorGainFocus, this );
+	}
+	getChild<LLViewerTextEditor>("Lua Output Editor",TRUE);
+	return TRUE;
 }
 
 void LLFloaterLuaConsole::draw()
 {
-        LLFloater::draw();
+	LLFloater::draw();
+}
+void LLFloaterLuaConsole::onInputEditorGainFocus( LLFocusableElement* caller, void* userdata )
+{
+	LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)userdata;
+	LLViewerTextEditor *editor = self->getChild<LLViewerTextEditor>("Lua Output Editor");
+	editor->setCursorAndScrollToEnd();
 }
-
 void LLFloaterLuaConsole::onClickSend(void *data)
 {
-        LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
-//        TSStuff *stuff = TSStuff::getInstance();
-//        TSLuaThread *thread = stuff->getThread();
-        LLLineEditor *editor = self->getChild<LLLineEditor>("Lua Editor", TRUE);
+	LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
+	LLLineEditor *editor = self->getChild<LLLineEditor>("Lua Editor", TRUE);
 
-        if(editor->getLength()) {
-//              thread->addCommand(editor->getText().c_str());
-		FLLua::getInstance()->RunString(editor->getText());
-                editor->updateHistory();
-                editor->clear();
-        }
+	if(editor->getLength()) 
+	{
+		LLColor4 text_color = gSavedSettings.getColor4("llOwnerSayChatColor");
+		LLViewerTextEditor *out = self->getChild<LLViewerTextEditor>("Lua Output Editor");
+		out->appendColoredText("] "+editor->getText(), false, true, text_color); //echo command, like a proper console.
+		FLLua::RunString(editor->getText());
+		editor->updateHistory();
+		editor->clear();
+	}
 }
 
 void LLFloaterLuaConsole::onClickAbort(void *data)
 {
-//        TSStuff *stuff = TSStuff::getInstance();
-//        stuff->getThread()->abort();
+	FLLua::cleanupClass(); //Unloads Lua
 }
 
 void LLFloaterLuaConsole::onClickReset(void *data)
 {
-        LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
+    LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
 
 	FLLua::init();
 
-        LLLineEditor *editor = self->getChild<LLLineEditor>("Lua Editor", TRUE);
+    LLLineEditor *editor = self->getChild<LLLineEditor>("Lua Editor", TRUE);
 
-        if(editor->getLength()) {
-                editor->updateHistory();
-                editor->clear();
-        }
+    if(editor->getLength()) 
+	{
+		editor->updateHistory();
+		editor->clear();
+	}
 }
 
 void LLFloaterLuaConsole::onClickClear(void *data)
 {
-        LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
-        LLViewerTextEditor *editor = self->getChild<LLViewerTextEditor>("Lua Output Editor");
-        editor->removeTextFromEnd(editor->getWText().length());
-        editor->makePristine();
+	LLFloaterLuaConsole *self = (LLFloaterLuaConsole *)data;
+	LLViewerTextEditor *editor = self->getChild<LLViewerTextEditor>("Lua Output Editor");
+	editor->removeTextFromEnd(editor->getWText().length());
+	editor->makePristine();
 }
+
+void LLFloaterLuaConsole::addOutput(std::string output, bool error)
+{
+	LLFloaterLuaConsole *self = sInstance;
+	if(!self) //open but hidden
+	{
+		self=getInstance();
+		self->setVisible(FALSE);
+	}
+	LLColor4 text_color;
+	if(error)
+		text_color = gSavedSettings.getColor4("ScriptErrorColor");
+	else
+		text_color = gSavedSettings.getColor4("ObjectChatColor");
+
+	LLViewerTextEditor *editor = self->getChild<LLViewerTextEditor>("Lua Output Editor");
+	editor->setParseHTML(TRUE);
+	editor->setParseHighlights(TRUE);
+	editor->appendColoredText(output, false, true, text_color);
+}
\ No newline at end of file
diff -daur indra/newview/flexconsole.h Update/newview/flexconsole.h
--- indra/newview/flexconsole.h	2009-12-26 16:57:40.013451700 -0600
+++ Update/newview/flexconsole.h	2009-12-27 23:55:50.040275600 -0600
@@ -25,7 +25,10 @@
         static bool isVisible() { if(sInstance) return (sInstance->getVisible() != FALSE); return false; }
         static void toggle(void*);
 
+		static void addOutput(std::string output, bool error);
+
 private:
+		static void	onInputEditorGainFocus(LLFocusableElement* caller,void* userdata);
         static void onClickSend(void*);
         static void onClickClear(void*);
         static void onClickAbort(void*);
diff -daur indra/newview/FLLua.cpp Update/newview/FLLua.cpp
--- indra/newview/FLLua.cpp	2009-12-26 16:57:40.560483000 -0600
+++ Update/newview/FLLua.cpp	2009-12-28 22:36:15.908374800 -0600
@@ -29,6 +29,7 @@
 *  - sInstance=FLLua() (THREAD,INTERPRETER)
 */
 #include "llviewerprecompiledheaders.h"
+
 #include <vector>
 #include <queue>
 #include <boost/tokenizer.hpp>
@@ -57,7 +58,7 @@
 #include "llrender.h"
 #include "llglheaders.h"
 #include "llversionviewer.h"
-
+#include <sstream>
 
 /* Lua classes */
 #include "LuaBase.h"
@@ -75,28 +76,69 @@
 // Hook Request 
 ///////////////////////////////////////////////
 
-HookRequest::HookRequest(const char *name)
+void HookRequest::Send()
 {
-	mName=name;
+	FLLua::callLuaHook(this);
 }
-
-void HookRequest::Add(const char *arg)
+HookRequest& HookRequest::operator<<(int in)
 {
-	mArgs.push_back(arg);
+	std::ostringstream out;
+	out << in;
+	mArgs.push_back(out.str());
+	return *this;
+}
+HookRequest& HookRequest::operator<<(float in)
+{
+	std::ostringstream out;
+	out << in;
+	mArgs.push_back(out.str());
+	return *this;
+}
+HookRequest& HookRequest::operator<<(std::string &in)
+{
+	mArgs.push_back(in);
+	return *this;
+}
+HookRequest& HookRequest::operator<<(const char *in)
+{
+	mArgs.push_back(in);
+	return *this;
+}
+HookRequest& HookRequest::operator<<(LLUUID &fullid)
+{
+	mArgs.push_back(fullid.asString());
+	return *this;
 }
 
 
 ///////////////////////////////////////////////
 // Lua Interpreter
 ///////////////////////////////////////////////
-FLLua::FLLua() :
-	LLThread("Lua")
+FLLua* FLLua::sInstance = NULL;
+
+FLLua::FLLua() : 
+	LLThread("Lua"), 
+	mError(false),
+	pLuaStack(NULL),
+	listening(false)
 {
 	// Do nothing.
 }
+FLLua::~FLLua()
+{
+	while(!mQueuedHooks.empty()) //these hooks are dynamically allocated. We must delete.
+	{
+		delete mQueuedHooks.front();
+		mQueuedHooks.pop();
+	}
+	if(pLuaStack)
+		lua_close(pLuaStack);
+	pLuaStack=NULL;
+	if(sInstance==this)//Just incase
+		sInstance=NULL;
+}
 
-FLLua* FLLua::sInstance = NULL;
-// static
+// Static
 FLLua* FLLua::getInstance()
 {
 	LL_WARNS("Lua") << "Lua interpreter should not be directly accessed!" << llendl;
@@ -104,151 +146,186 @@
 }
 
 // Static
-void FLLua::init()
+bool FLLua::init()
 {
 	LL_INFOS("Lua") << "Starting Lua..." << llendl;
+	cleanupClass();
 	sInstance=new FLLua();
+	if(!sInstance->load())
+	{
+		LL_INFOS("Lua") << "Failed to load Lua." << llendl;
+		cleanupClass();
+		return false;
+	}
 	sInstance->start();
-	FLLua::callLuaHook("OnLuaInit",0);
 	LL_INFOS("Lua") << "Lua started." << llendl;
+	LUA_CALL0("OnLuaInit");
+	return true;
 }
 
-// static
+// Static
 void FLLua::cleanupClass()
 {
-	sInstance=0;
+	if(sInstance)
+	{
+		delete sInstance;
+		sInstance=NULL;
+	}
 }
+// Static
+bool FLLua::isMacro(const std::string &str)
+{
+	return(str.substr(0,6)=="/macro" || str.substr(0,2)=="/m");
+}
+// Static
+void FLLua::callMacro(const std::string &command)
+{
+	if(!sInstance || (sInstance->mError && !FLLua::init()))
+		return;
 
-/// Run the interpreter.
-void FLLua::run()
+	sInstance->lockData();
+	sInstance->mQueuedCommands.push(command);
+	sInstance->unlockData();
+}
+//Static
+void FLLua::RunString(std::string s)
+{
+	if(!sInstance || (sInstance->mError && !FLLua::init()))
+		return;
+
+	if(luaL_dostring(sInstance->pLuaStack,s.c_str()))
+	{
+		LL_INFOS("Lua") << "Run string(" << s << ") failed with" << Lua_getErrorMessage(sInstance->pLuaStack) << llendl;
+		LuaError(Lua_getErrorMessage(sInstance->pLuaStack).c_str());
+	}
+}
+//Attempt to bind with Lua
+bool FLLua::load()
 {
 	LL_INFOS("Lua") << "Thread initializing." << llendl;
-	L = lua_open();
+	pLuaStack = lua_open();
+	if(!pLuaStack)
+	{
+		LL_INFOS("Lua") << __LINE__ << ": Failed lua_open" << llendl;
+		LuaError("lua_open() Failed");
+		return false;
+	}
 
 	LL_INFOS("Lua") << __LINE__ << ": Skipping lua_atpanic" << llendl;
-	lua_atpanic(L, luaOnPanic);
-
+	lua_atpanic(pLuaStack, luaOnPanic);
 
 	LL_INFOS("Lua") << __LINE__ << ": Loading standard Lua libs" << llendl;
-	luaL_openlibs(L);
-
+	luaL_openlibs(pLuaStack);
 
 	LL_INFOS("Lua") << __LINE__ << ": *** LOADING SWIG BINDINGS ***" << llendl;
-	luaopen_SL(L);
+	luaopen_SL(pLuaStack);
 
 	std::string  version; 
 
 	LL_INFOS("Lua") << __LINE__ << ": Assigning _SLUA_VERSION" << llendl;
 	// Assign _SLUA_VERSION, which contains the version number of the host viewer.
 	version = llformat("_SLUA_VERSION=\"%d.%d.%d.%d\"",LL_VERSION_MAJOR,LL_VERSION_MINOR,LL_VERSION_PATCH,LL_VERSION_BUILD);
-	luaL_dostring(L, version.c_str());
-
+	if(luaL_dostring(pLuaStack, version.c_str()))
+	{
+		LuaError(Lua_getErrorMessage(pLuaStack).c_str());
+		return false;
+	}
 
 	LL_INFOS("Lua") << __LINE__ << ": Assigning _SLUA_CHANNEL" << llendl;	
-	// Assign _SLUA_CHANNEL, which contains the channel name of the host client.
+	// Assign _SLUA_CHANNEpLuaStack, which contains the channel name of the host client.
 	version = llformat("_SLUA_CHANNEL=\"%s\"",LL_CHANNEL);
-	luaL_dostring(L, version.c_str());
-
+	if(luaL_dostring(pLuaStack, version.c_str()))
+	{
+		LuaError(Lua_getErrorMessage(pLuaStack).c_str());
+		return false;
+	}
 
 	LL_INFOS("Lua") << __LINE__ << ": Runfile (_init_.lua)" << llendl;
 	RunFile(gDirUtilp->getExpandedFilename(FL_PATH_LUA,"_init_.lua"));
-
+	if(mError)
+		return false;
 #if 0
 	RunFile(gDirUtilp->getExpandedFilename(FL_PATH_MACROS,"unit_tests.lua"));
+	if(mError)
+		return false;
 #endif
-
-
+	return true;
+}
+/// Run the interpreter.
+void FLLua::run()
+{
 	LL_INFOS("Lua") << __LINE__ << ": *** THREAD LOOP STARTS HERE ***" << llendl;
 	while(1)
 	{
+		if (!pLuaStack || LLApp::isError() || LLApp::isStopped())
+			break;	//Broked.
+			
+
 		// Process Hooks
 		lockData();
 
-
 		//LL_INFOS("Lua") << __LINE__ << ": Checking if hooks are empty" << llendl;
-		if(!mQueuedHooks.empty())
+		while(!mQueuedHooks.empty()) //Allow multiple hooks per loop.
 		{
-			LL_INFOS("Lua") << __LINE__ << ": Hooks not empty" << llendl;
+			//LL_INFOS("Lua") << __LINE__ << ": Hooks not empty" << llendl;
 
 			// Peek at the top of the stack
-			HookRequest *hr = NULL;
-			hr = mQueuedHooks.front();
+			HookRequest *hr = mQueuedHooks.front();	
+			ExecuteHook(hr);
 			mQueuedHooks.pop();
-			this->ExecuteHook(hr);		
-		} else {
-			LL_INFOS("Lua") << __LINE__ << ": Hooks empty" << llendl;
+			delete hr; //Say no to memory leaks.
 		}
-		LL_INFOS("Lua") << __LINE__ << ": Unlocking..." << llendl;
+		//else 
+		//{
+		//	LL_INFOS("Lua") << __LINE__ << ": Hooks empty" << llendl;
+		//}
+		//LL_INFOS("Lua") << __LINE__ << ": Unlocking..." << llendl;
 		unlockData();
 
 		if(mError)
-			return;
+			break;
 
 		// Process Macros/Raw Commands
-		LL_INFOS("Lua") << __LINE__ << ": Locking again..." << llendl;
+		//LL_INFOS("Lua") << __LINE__ << ": Locking again..." << llendl;
 		lockData();
 
-		LL_INFOS("Lua") << __LINE__ << ": Checking if macro queue is empty..." << llendl;
-		if(!mQueuedCommands.empty())
+		//LL_INFOS("Lua") << __LINE__ << ": Checking if macro queue is empty..." << llendl;
+		while(!mQueuedCommands.empty())
 		{
 		
-			LL_INFOS("Lua") << __LINE__ << ": Macro queued, executing it..." << llendl;
+			//LL_INFOS("Lua") << __LINE__ << ": Macro queued, executing it..." << llendl;
 
 			// Top of stack
-			std::string hr = mQueuedCommands.front();
-			mQueuedCommands.pop();
-
+			std::string &hr = mQueuedCommands.front(); //byref. faster.
 
-			LL_INFOS("Lua") << __LINE__ << ": Processing a macro or command." << llendl;
-			LL_INFOS("Lua") << __LINE__ << hr << llendl;
+			//LL_INFOS("Lua") << __LINE__ << ": Processing a macro or command." << llendl;
+			//LL_INFOS("Lua") << __LINE__ << hr << llendl;
 
 			// Is this shit a macro?
 			if(FLLua::isMacro(hr))
-				this->RunMacro(hr); // Run macro.
+				RunMacro(hr); // Run macro.
 			else
-				this->RunString(hr); // Run command.
-		} else {			
-			//LL_INFOS("Lua") << __LINE__ << ": Macro vector empty" << llendl;
-		}
+				RunString(hr); // Run command.
+
+			mQueuedCommands.pop(); //safe to pop now.
+		} 
+		//else 
+		//{			
+		//	LL_INFOS("Lua") << __LINE__ << ": Macro vector empty" << llendl;
+		//}
 		unlockData();
 		if(mError)
-			return;
+			break;
 		ms_sleep(10);
 	}
 	LL_INFOS("Lua") << __LINE__ << ": *** THREAD EXITING ***" << llendl;
 }
 
-void FLLua::callMacro(const std::string command)
-{
-	if(sInstance->mError)
-		FLLua::init();
-
-	sInstance->mQueuedCommands.push(command);
-}
-
-void FLHooks_InitTable(lua_State *l, FLLua* lol)
-{
-	FLLua** ud = reinterpret_cast<FLLua**>(lua_newuserdata(l, sizeof(FLLua*)));
-	
-	*ud = lol;
-
-	Lua_SetClass(l, "Hooks");
-}
-FLLua::~FLLua()
-{
-	lua_close(L);
-}
-
-void FLLua::RunString(std::string s)
-{
-	luaL_dostring(L,s.c_str());
-}
-
 void FLLua::RunFile(std::string  file)
 {
-	if(luaL_loadfile(L,file.c_str()) || lua_pcall(L,0,0,0))
+	if(luaL_loadfile(pLuaStack,file.c_str()) || lua_pcall(pLuaStack,0,0,0))
 	{
-		std::string  errmsg(Lua_getErrorMessage(L));
+		std::string  errmsg(Lua_getErrorMessage(pLuaStack));
 
 		llwarns << "Unable to load " << file << ": " << errmsg << llendl;
 			
@@ -256,23 +333,24 @@
 		LuaError(file.c_str());
 		LuaError(errmsg.c_str());
 		LuaError("Aborting.");
-	
+		lockData();
 		mError=true;
+		unlockData();
+	}
+	if(!listening)
+	{
+		lua_getglobal(pLuaStack,"CallHook"); //checking this every 10ms proved to be unstable. Only check once on load.
+		listening = lua_isfunction(pLuaStack,-1);
+		if(!listening)
+			lua_pop(pLuaStack,1);  
 	}
 }
-
-// static
-bool FLLua::isMacro(const std::string str)
-{
-	return(str.substr(0,6)=="/macro" || str.substr(0,2)=="/m");
-}
-
 void FLLua::RunMacro(const std::string what)
 {
 	std::string  tokenized = std::string (what.c_str());
 
 	BOOL found_macro = FALSE;
-	BOOL first_token = TRUE;
+	//BOOL first_token = TRUE;
 
 	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
 	boost::char_separator<char> sep(" ");
@@ -324,55 +402,95 @@
 	std::string  arglist("MACRO_ARGS={");
 	// HACK.  Set global via luaL_dostring
 	arglist.append(args.str()).append("};");
-	luaL_dostring(L,arglist.c_str());
-	this->RunFile(macrofile);
+	luaL_dostring(pLuaStack,arglist.c_str());
+	RunFile(macrofile);
 }
-
-// Static
-void FLLua::callLuaHook(const char *EventName,int numargs,...)
+//static
+void FLLua::callLuaHook(HookRequest *hook)
 {
-	if(sInstance->mError)
-		FLLua::init();
-
-	va_list arglist;
-    	va_start(arglist,numargs);
-
-	HookRequest* hook=new HookRequest(EventName);
-	for(int i = 0;i<numargs;i++)
-        {
-		hook->Add(va_arg(arglist,const char *));
-        }
-
-	FLLua::sInstance->mQueuedHooks.push(hook);
+	if(!hook)
+		return;
+	else if(!sInstance || (sInstance->mError && !FLLua::init()))
+		delete hook;
+	else
+	{
+#ifdef LUA_HOOK_SPAM
+		LL_INFOS("Lua") << "Adding event: " << hook.getName() << llendl;
+#endif
+		sInstance->lockData(); //Fixed a very obscure crash.
+		sInstance->mQueuedHooks.push(hook);
+		sInstance->unlockData();
+	}
 }
 
 void FLLua::ExecuteHook(HookRequest *hook)
 {
-	lua_getglobal(L,"CallHook");
 #ifdef LUA_HOOK_SPAM
 	LL_INFOS("Lua") << "Firing event: " << hook->getName() << llendl;
 #endif
-	if(lua_isfunction(L,1))
+	if(listening)
 	{
-		lua_pushstring(L,hook->getName());
-		for(int i = 0;i<hook->getNumArgs();i++)
-        	{
-			lua_pushstring(L,hook->getArg(i));
-        	}
-
-		if(lua_pcall(L,hook->getNumArgs()+1,0,0)!=0)
+		lua_getglobal(pLuaStack,"CallHook");
+		lua_pushstring(pLuaStack,hook->getName());
+		int lim=hook->getNumArgs();
+		if(lim)
+		{
+#ifdef LUA_HOOK_SPAM
+			LL_INFOS("Lua") << " args:";
+#endif
+			for(int i = 0;i<lim;i++)
+			{
+#ifdef LUA_HOOK_SPAM
+				LL_CONT << " " << hook->getArg(i);
+#endif
+				lua_pushstring(pLuaStack,hook->getArg(i));
+			}
+#ifdef LUA_HOOK_SPAM
+			LL_ENDL;
+#endif
+		}
+		if(lua_pcall(pLuaStack,hook->getNumArgs()+1,1,0)!=0)
 		{
 			char errbuff[1024];
-			sprintf(errbuff,"Error executing the %s hook: %s",hook->getName(),lua_tostring(L,-1));
+			sprintf(errbuff,"Error executing the %s hook: %s",hook->getName(),lua_tostring(pLuaStack,-1));
 			LuaError(errbuff);
 		}
+#ifdef LUA_HOOK_SPAM
+		else
+		{
+			const char *str = lua_tostring(pLuaStack,-1);
+			if(atoi(str))
+				LL_INFOS("Lua") << " called " << str << " callbacks" << llendl;
+		}
+#endif
 	}
 }
 
+int luaOnPanic(lua_State *L)
+{	
+	LuaError(("Lua Error: "+Lua_getErrorMessage(L)).c_str());
+	return 0;
+}
 
+std::string  Lua_getErrorMessage(lua_State *L)
+{
+	if (lua_gettop(L) > 0)
+	{
+		if (lua_isstring(L, -1))
+			return lua_tostring(L, -1);
+	}
+	return "";
+}
 
+/*void FLHooks_InitTable(lua_State *l, FLLua* lol)
+{
+	FLLua** ud = reinterpret_cast<FLLua**>(lua_newuserdata(l, sizeof(FLLua*)));
+	
+	*ud = lol;
 
-
+	Lua_SetClass(l, "Hooks");
+}*/
+/*
 void Lua_RegisterMethod(lua_State* l, const char* name, lua_CFunction fn)
 {
 
@@ -440,22 +558,6 @@
 	lua_pushlstring(l, classname, strlen(classname));
 }
 
-int luaOnPanic(lua_State *L)
-{	
-	LuaError("Lua Error: "+Lua_getErrorMessage(L));
-	return 0;
-}
-
-std::string  Lua_getErrorMessage(lua_State *L)
-{
-	if (lua_gettop(L) > 0)
-	{
-		if (lua_isstring(L, -1))
-			return lua_tostring(L, -1);
-	}
-	return "";
-}
-
 void Lua_SetClass(lua_State *l,const char* classname)
 {
 	Lua_PushClass(l,classname);
@@ -465,6 +567,8 @@
 	if (lua_setmetatable(l, -2) == 0)
 		llwarns << "Error setting metatable for " << classname << llendl;
 }
+*/
+
 
 
 /*
diff -daur indra/newview/FLLua.h Update/newview/FLLua.h
--- indra/newview/FLLua.h	2009-12-26 16:57:40.517480600 -0600
+++ Update/newview/FLLua.h	2009-12-28 22:38:33.362236700 -0600
@@ -28,69 +28,101 @@
 #include <vector>
 
 extern "C" {
-	#include "lua/lua.h"
-	#include "lua/lauxlib.h"
-	#include "lua/lualib.h"
+	#include "lua.h"
+	#include "lauxlib.h"
+	#include "lualib.h"
 }
 
 #include "llstring.h"
-//typedef std::string LLString; // Fixing broken LL code.
 #include "message.h"
 #include "llviewerimage.h"
 
+//Macros for Lua event calls
+//No arguments. LUA_CALL0("OnSomething");
+//Arguments.	LUA_CALL("OnSomething") << arg1 << arg2 << ... << LUA_END;
+class lua_done {};
+#define LUA_CALL0(name) do{(new HookRequest(name))->Send();}while(0)
+#define LUA_CALL(name) do{(*(new HookRequest(name))) 
+#define LUA_END (lua_done*)0;}while(0)
+
 class HookRequest
 {
 public:
-	HookRequest(const char *Name);
+	//These overrides create a simple shift method for adding arguments painlessly.
+	//If unhandled type use add.
+	HookRequest& operator<<(int in);
+	HookRequest& operator<<(float in);
+	HookRequest& operator<<(std::string &in);
+	HookRequest& operator<<(const char *in);
+	HookRequest& operator<<(LLUUID &in);
+	HookRequest& operator<<(lua_done *in)
+		{Send(); return *this;}//Send off.
 
-	void Add(const char *arg);
-	
-	const char* getName(){ return mName; }
-	const char* getArg(unsigned idx){ return mArgs[idx]; }
-	int getNumArgs(){ return mArgs.size(); };
+	HookRequest(const char *Name) { mName=Name; }
+	HookRequest(){} //Should do nothing. may resolve compiler bug on MSVC
+	const char* getName()
+		{return mName.c_str(); }
+	void add(std::string &in)
+		{mArgs.push_back(in);}
+	const char* getArg(unsigned idx)
+		{return (idx >= 0 && idx < mArgs.size()) ? mArgs[idx].c_str() : NULL;}
+	int getNumArgs()
+		{return mArgs.size(); };
+
+	void Send();
 private:
-	std::vector<const char *> mArgs;
-	const char *mName;
+	std::vector<std::string> mArgs;
+	std::string mName;
 };
 
 class FLLua : public LLThread
 {
+friend class HookRequest;
 	//LOG_CLASS(FLLua);
 public:
 	FLLua();
 	~FLLua();
 
-	static void init();
+	static bool init();
 	static void cleanupClass();
 
 	static FLLua* getInstance();
 
-	static void callLuaHook(const char *EventName,int numargs,...);
-	void RunString(std::string s);
-	void run();
-
-	void RunFile(std::string file);
-	static bool isMacro(const std::string what);
-	static void callMacro(const std::string cmd);
+	static bool isMacro(const std::string &what);
+	static void callMacro(const std::string &cmd);
+	static void RunString(std::string s); //static'd
 
-	// Is shit broken?
-	bool mError;
 private:
+
+	bool load(); //pulled out of run so we can determine if load failed immediately.
+
+	void run();
+	
+	void RunFile(std::string file);
 	void RunMacro(const std::string what);
+	void ExecuteHook(HookRequest *hook);
+
+	static void callLuaHook(HookRequest *hook);
 	
-	lua_State *L; // Lua stack
 	static FLLua *sInstance;
-
+	// Lua stack
+	lua_State *pLuaStack; 
 	// Queued hooks
 	std::queue<HookRequest*> mQueuedHooks;
 	std::queue<std::string> mQueuedCommands;
-
-
-	void ExecuteHook(HookRequest *hook);
+	// Is shit broken.
+	bool mError;
+	// Is CallHook present.
+	bool listening;
 };
 
+int luaOnPanic(lua_State *L);
+std::string Lua_getErrorMessage(lua_State *L);
+
 //extern FLLua *gLuaHooks;
 
+//Unused
+/*
 void FLHooks_CreateMetatable(lua_State *L);
 void FLHooks_InitTable(lua_State *L, FLLua* lol);
 int FLHooks_SetHook(lua_State* l);
@@ -103,9 +135,7 @@
 void Lua_CreateClassMetatable(lua_State* l, const char* name);
 void Lua_CheckArgs(lua_State* l,int minArgs, int maxArgs, const char* errorMessage);
 void Lua_PushClass(lua_State* l, const char* classname);
-
-int luaOnPanic(lua_State *L);
-std::string Lua_getErrorMessage(lua_State *L);
+*/
 
 void LuaSetAvOverlay(const char *uuid,int type);
 
diff -daur indra/newview/llagent.cpp Update/newview/llagent.cpp
--- indra/newview/llagent.cpp	2009-12-26 16:57:40.709491500 -0600
+++ Update/newview/llagent.cpp	2009-12-28 22:41:06.238980800 -0600
@@ -458,7 +458,7 @@
 	// Run a lua hook
 	std::string lolname;
 	this->getName(lolname);
-	FLLua::callLuaHook("OnAgentInit",2,lolname.c_str(),(const char *)isGodlike());
+	LUA_CALL("OnAgentInit") << lolname << (int)isGodlike() << LUA_END;
 }
 
 //-----------------------------------------------------------------------------
@@ -792,7 +792,7 @@
 void LLAgent::setPhantom(BOOL phantom)
 {
 	emeraldPhantom = phantom;
-	FLLua::callLuaHook("EmeraldPhantomOn",1,phantom);
+	LUA_CALL("EmeraldPhantomOn") << phantom << LUA_END;
 }
 //-----------------------------------------------------------------------------
 // getPhantom()  lgg
diff -daur indra/newview/llviewerobjectlist.cpp Update/newview/llviewerobjectlist.cpp
--- indra/newview/llviewerobjectlist.cpp	2009-12-26 16:57:40.681489900 -0600
+++ Update/newview/llviewerobjectlist.cpp	2009-12-28 22:44:07.295336600 -0600
@@ -1361,7 +1361,7 @@
 
 	updateActive(objectp);
 
-	FLLua::callLuaHook("OnObjectCreated",2,fullid.asString().c_str(),LLPrimitive::pCodeToString(pcode).c_str());
+	LUA_CALL("OnObjectCreated") << fullid << LLPrimitive::pCodeToString(pcode) << LUA_END;
 
 	return objectp;
 }
diff -daur indra/newview/llvoavatar.cpp Update/newview/llvoavatar.cpp
--- indra/newview/llvoavatar.cpp	2009-12-26 16:57:39.579426900 -0600
+++ Update/newview/llvoavatar.cpp	2009-12-28 22:47:12.027902700 -0600
@@ -6640,7 +6640,7 @@
 {
 	LLViewerJointAttachment* attachment = getTargetAttachmentPoint(viewer_object);
 	
-	FLLua::callLuaHook("OnAttach",2,viewer_object->getID().getString().c_str(),getFullname().c_str());
+	LUA_CALL("OnAttach") << viewer_object->getID().getString() << getFullname() << LUA_END;
 
 	if (!attachment || !attachment->addObject(viewer_object))
 	{
diff -daur indra/newview/lua/_init_.lua Update/newview/lua/_init_.lua
--- indra/newview/lua/_init_.lua	2009-12-26 16:55:03.528501300 -0600
+++ Update/newview/lua/_init_.lua	2009-12-28 22:59:41.362762200 -0600
@@ -72,6 +72,20 @@
 	return coroutine.wrap(function() yieldtree(dir) end)
 end
 
+--Easily check contents of _G and SL
+function DumpTable(tbl)
+	for n,v in pairs(tbl) do
+		print (n,v)
+	end
+end
+
+--Override print.
+function print(str) 
+	--Need to decide if this goes to chat or if we need to 
+	--create a seprate function for that.
+	SL.print(str) --Always prints to chat. Do we want this?
+end
+
 -- String functions
 function string.starts(String,Start)
    return string.sub(String,1,string.len(Start))==Start
diff -daur indra/newview/lua/EventHandling.lua Update/newview/lua/EventHandling.lua
--- indra/newview/lua/EventHandling.lua	2009-12-26 16:55:03.535501700 -0600
+++ Update/newview/lua/EventHandling.lua	2009-12-27 20:26:27.225723700 -0600
@@ -33,8 +33,10 @@
 
 -- Should only be called from FlexLife's C++ code, or from a package that initialized the event called.
 function CallHook(EventName,...)
-	if(gEvents[EventName]==nil) then return end -- No hooks to call, so exit.
-	for _,hookedfunc in pairs(gEvents[EventName]) do hookedfunc(...) end
+	if(gEvents[EventName]==nil) then return 0 end -- No hooks to call, so exit.
+	val=0
+	for _,hookedfunc in pairs(gEvents[EventName]) do hookedfunc(...) val=val + 1 end
+	return val
 end
 
 function RegisterHook(EventName,Desc)
@@ -51,4 +53,5 @@
 	for name,_ in pairs(gEvents) do
 		print(name)
 	end
+	return table.concat(gEvents,"\n")
 end
diff -daur indra/newview/LuaAgent_f.cpp Update/newview/LuaAgent_f.cpp
--- indra/newview/LuaAgent_f.cpp	2009-12-26 16:57:39.981449900 -0600
+++ Update/newview/LuaAgent_f.cpp	2009-12-28 22:49:43.608572600 -0600
@@ -1,5 +1,6 @@
 #include "llviewerprecompiledheaders.h"
 
+#include "LuaBase_f.h"
 #include "LuaAgent_f.h"
 
 #include "llviewerobjectlist.h"
@@ -47,6 +48,11 @@
 {
 	std::string  name;
 	LLUUID id(uuid);
+	if(!gCacheName)
+	{
+		LuaError("gCacheName is NULL");
+		return "";
+	}
 	gCacheName->getFullName(id,name);
 	return name;
 }
@@ -55,6 +61,11 @@
 {
 	std::string  name(fullname);
 	LLVOAvatar *av=gObjectList.findAvatar(name);
+	if(!av)
+	{
+		LuaError("No Avatar Found");
+		return "";
+	}
 	return av->getID().asString();
 }
 
@@ -81,4 +92,4 @@
 {
 	LLSimInfo* wut = LLWorldMap::getInstance()->simInfoFromName(std::string (name));
 	return wut;
-}
\ No newline at end of file
+}
diff -daur indra/newview/LuaAvatar_f.cpp Update/newview/LuaAvatar_f.cpp
--- indra/newview/LuaAvatar_f.cpp	2009-12-26 16:57:39.783438600 -0600
+++ Update/newview/LuaAvatar_f.cpp	2009-12-28 22:50:37.394649000 -0600
@@ -1,6 +1,8 @@
 #include "llviewerprecompiledheaders.h"
-#include "LuaAvatar_f.h"
+
 #include "LuaBase_f.h"
+#include "LuaAvatar_f.h"
+
 #include "llagent.h"
 #include "llvoavatar.h"
 #include "llviewerobjectlist.h"
@@ -96,6 +98,13 @@
 	}
 	LLVOAvatar *av=(LLVOAvatar *)o;
 	LLVisualParam *p=av->getVisualParam(paramname);
+	if(!p)
+	{
+		std::string out("Invalid visual parameter: ");
+		out.append(paramname);
+		LuaError(out.c_str());
+		return 0;
+	}
 	return (double)p->getDefaultWeight();
 }
 
@@ -110,6 +119,13 @@
 	}
 	LLVOAvatar *av=(LLVOAvatar *)o;
 	LLVisualParam *p=av->getVisualParam(paramname);
+	if(!p)
+	{
+		std::string out("Invalid visual parameter: ");
+		out.append(paramname);
+		LuaError(out.c_str());
+		return 0;
+	}
 	return (double)p->getCurrentWeight();
 }
 
@@ -124,6 +140,13 @@
 	}
 	LLVOAvatar *av=(LLVOAvatar *)o;
 	LLVisualParam *p=av->getVisualParam(paramname);
+	if(!p)
+	{
+		std::string out("Invalid visual parameter: ");
+		out.append(paramname);
+		LuaError(out.c_str());
+		return 0;
+	}
 	return (double)p->getMaxWeight();
 }
 
@@ -138,6 +161,13 @@
 	}
 	LLVOAvatar *av=(LLVOAvatar *)o;
 	LLVisualParam *p=av->getVisualParam(paramname);
+	if(!p)
+	{
+		std::string out("Invalid visual parameter: ");
+		out.append(paramname);
+		LuaError(out.c_str());
+		return 0;
+	}
 	return (double)p->getMinWeight();
 }
 
@@ -148,7 +178,19 @@
 void setParamOnSelf(const char* paramname,double weight)
 {
 	LLVOAvatar *me=gAgent.getAvatarObject();
+	if(!me)
+	{
+		LuaError("No Agent Avatar");
+		return;
+	}
 	LLVisualParam *p=me->getVisualParam(paramname);
+	if(!p)
+	{
+		std::string out("Invalid visual parameter: ");
+		out.append(paramname);
+		LuaError(out.c_str());
+		return;
+	}
 	p->setWeight((F32)weight,FALSE);
 	me->setVisualParamWeight(p,p->getCurrentWeight());
 	gAgent.setAvatarObject(me);
@@ -157,8 +199,17 @@
 void LuaWear(const char* assetid)
 {
 	LLWearable *wear=LuaLoadWearable(assetid);
-	
+	if(!wear)
+	{
+		LuaError("No Wearable found");
+		return;
+	}
 	LLWearable *newwear=gWearableList.createCopy(wear);
+	if(!wear)
+	{
+		LuaError("Failed creation of new wearable");
+		return;
+	}
 	newwear->saveNewAsset();
 	newwear->writeToAvatar(false);
 }
@@ -170,6 +221,8 @@
 
 bool LuaSaveWearable(LLWearable *w)
 {
+	if(!w)
+		return false;
 	//Buffer to hold the char[] version of the LLUUID
 	char new_asset_id_string[UUID_STR_LENGTH];
 
@@ -259,6 +312,11 @@
 void LuaSetTEImage(int index,const char *UUID)
 {
 	LLVOAvatar *a=gAgent.getAvatarObject();
+	if(!a)
+	{
+		LuaError("No Agent Avatar");
+		return;
+	}
 	LLUUID imid;
 	imid.set(UUID);
 	a->setTEImage((U8)index,new LLViewerImage(imid));
diff -daur indra/newview/LuaBase.cpp Update/newview/LuaBase.cpp
--- indra/newview/LuaBase.cpp	2009-12-26 16:57:39.402416800 -0600
+++ Update/newview/LuaBase.cpp	2009-12-28 22:51:23.339276900 -0600
@@ -1,3409 +1,7 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 1.3.36
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-
-#ifdef __cplusplus
-template<typename T> class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T& t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
-    operator T&() const { return *tt; }
-    T *operator&() { return tt; }
-private:
-    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-};
-
-template <typename T> T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIG_MSC_UNSUPPRESS_4505
-# if defined(_MSC_VER)
-#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
-# endif 
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility("default")))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic CAPI SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "4"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the swig runtime code.
-  In 99.9% of the cases, swig just needs to declare them as 'static'.
-  
-  But only do this if is strictly necessary, ie, if you have problems
-  with your compiler or so.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-#define SWIG_CAST_NEW_MEMORY       0x2
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The swig conversion methods, as ConvertPtr, return and integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old swig versions, you usually write code as:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit as:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   that seems to be the same, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   requires also to SWIG_ConvertPtr to return new result values, as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (<obj is ok>) {			       
-          if (<need new object>) {		       
-            *ptr = <ptr to new allocated object>; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = <ptr to old object>;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   swig errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -> 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-
-
- */
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r >= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 << 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
-
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *, int *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store information on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCompare(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-
-/* think of this as a c++ template<> or a scheme macro */
-#define SWIG_TypeCheck_Template(comparison, ty)         \
-  if (ty) {                                             \
-    swig_cast_info *iter = ty->cast;                    \
-    while (iter) {                                      \
-      if (comparison) {                                 \
-        if (iter == ty->cast) return iter;              \
-        /* Move iter to the top of the linked list */   \
-        iter->prev->next = iter->next;                  \
-        if (iter->next)                                 \
-          iter->next->prev = iter->prev;                \
-        iter->next = ty->cast;                          \
-        iter->prev = 0;                                 \
-        if (ty->cast) ty->cast->prev = iter;            \
-        ty->cast = iter;                                \
-        return iter;                                    \
-      }                                                 \
-      iter = iter->next;                                \
-    }                                                   \
-  }                                                     \
-  return 0
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
-}
-
-/* Same as previous function, except strcmp is replaced with a pointer comparison */
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
-  SWIG_TypeCheck_Template(iter->type == from, into);
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti->cast;
-  /* if (ti->clientdata == clientdata) return; */
-  ti->clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast->converter) {
-      swig_type_info *tc = cast->type;
-      if (!tc->clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast->next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti->owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - http://www.swig.org/release.html.
- *
- * luarun.swg
- *
- * This file contains the runtime support for Lua modules
- * and includes code for managing global variables and pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "lua.h"
-#include "lauxlib.h"
-#include <stdlib.h>  /* for malloc */
-#include <assert.h>  /* for a few sanity tests */
-
-/* -----------------------------------------------------------------------------
- * global swig types
- * ----------------------------------------------------------------------------- */
-/* Constant table */
-#define SWIG_LUA_INT     1
-#define SWIG_LUA_FLOAT   2
-#define SWIG_LUA_STRING  3
-#define SWIG_LUA_POINTER 4
-#define SWIG_LUA_BINARY  5
-#define SWIG_LUA_CHAR    6
-
-/* Structure for variable linking table */
-typedef struct {
-  const char *name;
-  lua_CFunction get;
-  lua_CFunction set;
-} swig_lua_var_info;
-
-/* Constant information structure */
-typedef struct {
-    int type;
-    char *name;
-    long lvalue;
-    double dvalue;
-    void   *pvalue;
-    swig_type_info **ptype;
-} swig_lua_const_info;
-
-typedef struct {
-  const char     *name;
-  lua_CFunction   method;
-} swig_lua_method;
-
-typedef struct {
-  const char     *name;
-  lua_CFunction   getmethod;
-  lua_CFunction   setmethod;
-} swig_lua_attribute;
-
-typedef struct swig_lua_class {
-  const char    *name;
-  swig_type_info   **type;
-  lua_CFunction  constructor;
-  void    (*destructor)(void *);
-  swig_lua_method   *methods;
-  swig_lua_attribute     *attributes;
-  struct swig_lua_class **bases;
-  const char **base_names;
-} swig_lua_class;
-
-/* this is the struct for wrappering all pointers in SwigLua
-*/
-typedef struct {
-  swig_type_info   *type;
-  int     own;  /* 1 if owned & must be destroyed */
-  void        *ptr;
-} swig_lua_userdata;
-
-/* this is the struct for wrapping arbitary packed binary data
-(currently it is only used for member function pointers)
-the data ordering is similar to swig_lua_userdata, but it is currently not possible
-to tell the two structures apart within Swig, other than by looking at the type
-*/
-typedef struct {
-  swig_type_info   *type;
-  int     own;  /* 1 if owned & must be destroyed */
-  char data[1];       /* arbitary amount of data */    
-} swig_lua_rawdata;
-
-/* Common SWIG API */
-#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
-#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
-#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
-#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)
-
-/* Runtime API */
-#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
-#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
-#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*
-
-/* Contract support */
-#define SWIG_contract_assert(expr, msg)  \
-  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else
-
-/* helper #defines */
-#define SWIG_fail {goto fail;}
-#define SWIG_fail_arg(func_name,argnum,type) \
-  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
-  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
-  goto fail;}
-#define SWIG_fail_ptr(func_name,argnum,type) \
-  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
-#define SWIG_check_num_args(func_name,a,b) \
-  if (lua_gettop(L)<a || lua_gettop(L)>b) \
-  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
-  goto fail;}
-
-
-#define SWIG_Lua_get_table(L,n) \
-  (lua_pushstring(L, n), lua_rawget(L,-2))
-
-#define SWIG_Lua_add_function(L,n,f) \
-  (lua_pushstring(L, n), \
-      lua_pushcfunction(L, f), \
-      lua_rawset(L,-3))
-
-/* special helper for allowing 'nil' for usertypes */
-#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))
-
-#ifdef __cplusplus
-/* Special helper for member function pointers 
-it gets the address, casts it, then dereferences it */
-//#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
-#endif
-
-/* storing/access of swig_module_info */
-SWIGRUNTIME swig_module_info *
-SWIG_Lua_GetModule(lua_State* L) {
-  swig_module_info *ret = 0;
-  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
-  lua_rawget(L,LUA_REGISTRYINDEX);
-  if (lua_islightuserdata(L,-1))
-    ret=(swig_module_info*)lua_touserdata(L,-1);
-  lua_pop(L,1);  /* tidy */
-  return ret;
-}
-
-SWIGRUNTIME void
-SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
-  /* add this all into the Lua registry: */
-  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
-  lua_pushlightuserdata(L,(void*)module);
-  lua_rawset(L,LUA_REGISTRYINDEX);
-}
-
-/* -----------------------------------------------------------------------------
- * global variable support code: modules
- * ----------------------------------------------------------------------------- */
-
-/* this function is called when trying to set an immutable.
-default value is to print an error.
-This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
-SWIGINTERN int SWIG_Lua_set_immutable(lua_State* L)
-{
-/*  there should be 1 param passed in: the new value */
-#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
-  lua_pop(L,1);  /* remove it */
-  lua_pushstring(L,"This variable is immutable");
-  lua_error(L);
-#endif
-    return 0;   /* should not return anything */
-}
-
-/* the module.get method used for getting linked data */
-SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
-{
-/*  there should be 2 params passed in
-  (1) table (not the meta table)
-  (2) string name of the attribute
-  printf("SWIG_Lua_module_get %p(%s) '%s'\n",
-   lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
-   lua_tostring(L,2));
-*/
-  /* get the metatable */
-  assert(lua_istable(L,1));  /* just in case */
-  lua_getmetatable(L,1);  /* get the metatable */
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_get_table(L,".get");  /* get the .get table */
-  lua_remove(L,3);  /* remove metatable */
-  if (lua_istable(L,-1))
-  {
-    /* look for the key in the .get table */
-    lua_pushvalue(L,2);  /* key */
-    lua_rawget(L,-2);
-    lua_remove(L,3);  /* remove .get */
-    if (lua_iscfunction(L,-1))
-    {  /* found it so call the fn & return its value */
-      lua_call(L,0,1);
-      return 1;
-    }
-    lua_pop(L,1);  /* remove the top */
-  }
-  lua_pop(L,1);  /* remove the .get */
-  lua_pushnil(L);  /* return a nil */
-    return 1;
-}
-
-/* the module.set method used for setting linked data */
-SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
-{
-/*  there should be 3 params passed in
-  (1) table (not the meta table)
-  (2) string name of the attribute
-  (3) any for the new value
-*/
-  /* get the metatable */
-  assert(lua_istable(L,1));  /* just in case */
-  lua_getmetatable(L,1);  /* get the metatable */
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_get_table(L,".set");  /* get the .set table */
-  lua_remove(L,4);  /* remove metatable */
-  if (lua_istable(L,-1))
-  {
-    /* look for the key in the .set table */
-    lua_pushvalue(L,2);  /* key */
-    lua_rawget(L,-2);
-    lua_remove(L,4);  /* remove .set */
-    if (lua_iscfunction(L,-1))
-    {  /* found it so call the fn & return its value */
-      lua_pushvalue(L,3);  /* value */
-      lua_call(L,1,0);
-      return 0;
-    }
-  }
-  lua_settop(L,3);  /* reset back to start */
-  /* we now have the table, key & new value, so just set directly */
-  lua_rawset(L,1);  /* add direct */
-  return 0;
-}
-
-/* registering a module in lua */
-SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
-{
-  assert(lua_istable(L,-1));  /* just in case */
-  lua_pushstring(L,name);
-  lua_newtable(L);   /* the table */
-  /* add meta table */
-  lua_newtable(L);    /* the meta table */
-  SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
-  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
-  lua_pushstring(L,".get");
-  lua_newtable(L);    /* the .get table */
-  lua_rawset(L,-3);  /* add .get into metatable */
-  lua_pushstring(L,".set");
-  lua_newtable(L);    /* the .set table */
-  lua_rawset(L,-3);  /* add .set into metatable */
-  lua_setmetatable(L,-2);  /* sets meta table in module */
-  lua_rawset(L,-3);        /* add module into parent */
-  SWIG_Lua_get_table(L,name);   /* get the table back out */
-}
-
-/* ending the register */
-SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
-{
-  lua_pop(L,1);       /* tidy stack (remove module) */
-}
-
-/* adding a linked variable to the module */
-SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
-{
-  assert(lua_istable(L,-1));  /* just in case */
-  lua_getmetatable(L,-1);  /* get the metatable */
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_get_table(L,".get"); /* find the .get table */
-  assert(lua_istable(L,-1));  /* should be a table: */
-  SWIG_Lua_add_function(L,name,getFn);
-  lua_pop(L,1);       /* tidy stack (remove table) */
-  if (setFn)  /* if there is a set fn */
-  {
-    SWIG_Lua_get_table(L,".set"); /* find the .set table */
-    assert(lua_istable(L,-1));  /* should be a table: */
-    SWIG_Lua_add_function(L,name,setFn);
-    lua_pop(L,1);       /* tidy stack (remove table) */
-  }
-  lua_pop(L,1);       /* tidy stack (remove meta) */
-}
-
-/* adding a function module */
-SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
-{
-  SWIG_Lua_add_function(L,name,fn);
-}
-
-/* -----------------------------------------------------------------------------
- * global variable support code: classes
- * ----------------------------------------------------------------------------- */
-
-/* the class.get method, performs the lookup of class attributes */
-SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
-{
-/*  there should be 2 params passed in
-  (1) userdata (not the meta table)
-  (2) string name of the attribute
-*/
-  assert(lua_isuserdata(L,-2));  /* just in case */
-  lua_getmetatable(L,-2);    /* get the meta table */
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_get_table(L,".get"); /* find the .get table */
-  assert(lua_istable(L,-1));  /* just in case */
-  /* look for the key in the .get table */
-  lua_pushvalue(L,2);  /* key */
-  lua_rawget(L,-2);
-  lua_remove(L,-2); /* stack tidy, remove .get table */
-  if (lua_iscfunction(L,-1))
-  {  /* found it so call the fn & return its value */
-    lua_pushvalue(L,1);  /* the userdata */
-    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
-    lua_remove(L,-2); /* stack tidy, remove metatable */
-    return 1;
-  }
-  lua_pop(L,1);  /* remove whatever was there */
-  /* ok, so try the .fn table */
-  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
-  assert(lua_istable(L,-1));  /* just in case */
-  lua_pushvalue(L,2);  /* key */
-  lua_rawget(L,-2);  /* look for the fn */
-  lua_remove(L,-2); /* stack tidy, remove .fn table */
-  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
-  {  /* found it so return the fn & let lua call it */
-    lua_remove(L,-2); /* stack tidy, remove metatable */
-    return 1;
-  }
-  lua_pop(L,1);  /* remove whatever was there */
-  /* NEW: looks for the __getitem() fn
-  this is a user provided get fn */
-  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
-  if (lua_iscfunction(L,-1))  /* if its there */
-  {  /* found it so call the fn & return its value */
-    lua_pushvalue(L,1);  /* the userdata */
-    lua_pushvalue(L,2);  /* the parameter */
-    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
-    lua_remove(L,-2); /* stack tidy, remove metatable */
-    return 1;
-  }
-  return 0;  /* sorry not known */
-}
-
-/* the class.set method, performs the lookup of class attributes */
-SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
-{
-/*  there should be 3 params passed in
-  (1) table (not the meta table)
-  (2) string name of the attribute
-  (3) any for the new value
-printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
-      lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
-      lua_tostring(L,2),
-      lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/
-
-  assert(lua_isuserdata(L,1));  /* just in case */
-  lua_getmetatable(L,1);    /* get the meta table */
-  assert(lua_istable(L,-1));  /* just in case */
-
-  SWIG_Lua_get_table(L,".set"); /* find the .set table */
-  if (lua_istable(L,-1))
-  {
-    /* look for the key in the .set table */
-    lua_pushvalue(L,2);  /* key */
-    lua_rawget(L,-2);
-    if (lua_iscfunction(L,-1))
-    {  /* found it so call the fn & return its value */
-      lua_pushvalue(L,1);  /* userdata */
-      lua_pushvalue(L,3);  /* value */
-      lua_call(L,2,0);
-      return 0;
-    }
-    lua_pop(L,1);  /* remove the value */
-  }
-  lua_pop(L,1);  /* remove the value .set table */
-  /* NEW: looks for the __setitem() fn
-  this is a user provided set fn */
-  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
-  if (lua_iscfunction(L,-1))  /* if its there */
-  {  /* found it so call the fn & return its value */
-    lua_pushvalue(L,1);  /* the userdata */
-    lua_pushvalue(L,2);  /* the parameter */
-    lua_pushvalue(L,3);  /* the value */
-    lua_call(L,3,0);  /* 3 values in ,0 out */
-    lua_remove(L,-2); /* stack tidy, remove metatable */
-    return 1;
-  }
-  return 0;
-}
-
-/* the class.destruct method called by the interpreter */
-SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
-{
-/*  there should be 1 params passed in
-  (1) userdata (not the meta table) */
-  swig_lua_userdata* usr;
-  swig_lua_class* clss;
-  assert(lua_isuserdata(L,-1));  /* just in case */
-  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
-  /* if must be destroyed & has a destructor */
-  if (usr->own) /* if must be destroyed */
-  {
-    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
-    if (clss && clss->destructor)  /* there is a destroy fn */
-    {
-      clss->destructor(usr->ptr);  /* bye bye */
-    }
-  }
-  return 0;
-}
-
-/* gets the swig class registry (or creates it) */
-SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
-{
-  /* add this all into the swig registry: */
-  lua_pushstring(L,"SWIG");
-  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
-  if (!lua_istable(L,-1))  /* not there */
-  {  /* must be first time, so add it */
-    lua_pop(L,1);  /* remove the result */
-    lua_pushstring(L,"SWIG");
-    lua_newtable(L);
-    lua_rawset(L,LUA_REGISTRYINDEX);
-    /* then get it */
-    lua_pushstring(L,"SWIG");
-    lua_rawget(L,LUA_REGISTRYINDEX);
-  }
-}
-
-/* helper fn to get the classes metatable from the register */
-SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
-{
-  SWIG_Lua_get_class_registry(L);  /* get the registry */
-  lua_pushstring(L,cname);  /* get the name */
-  lua_rawget(L,-2);    /* get it */
-  lua_remove(L,-2);    /* tidy up (remove registry) */
-}
-
-/* helper add a variable to a registered class */
-SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
-{
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_get_table(L,".get"); /* find the .get table */
-  assert(lua_istable(L,-1));  /* just in case */
-  SWIG_Lua_add_function(L,name,getFn);
-  lua_pop(L,1);       /* tidy stack (remove table) */
-  if (setFn)
-  {
-    SWIG_Lua_get_table(L,".set"); /* find the .set table */
-    assert(lua_istable(L,-1));  /* just in case */
-    SWIG_Lua_add_function(L,name,setFn);
-    lua_pop(L,1);       /* tidy stack (remove table) */
-  }
-}
-
-/* helper to recursively add class details (attributes & operations) */
-SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
-{
-  int i;
-  /* call all the base classes first: we can then override these later: */
-  for(i=0;clss->bases[i];i++)
-  {
-    SWIG_Lua_add_class_details(L,clss->bases[i]);
-  }
-  /* add fns */
-  for(i=0;clss->attributes[i].name;i++){
-    SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
-  }
-  /* add methods to the metatable */
-  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
-  assert(lua_istable(L,-1));  /* just in case */
-  for(i=0;clss->methods[i].name;i++){
-    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
-  }
-  lua_pop(L,1);       /* tidy stack (remove table) */
-  /*   add operator overloads
-    these look ANY method which start with "__" and assume they
-    are operator overloads & add them to the metatable
-    (this might mess up is someone defines a method __gc (the destructor)*/
-  for(i=0;clss->methods[i].name;i++){
-    if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
-      SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
-    }
-  }
-}
-
-/* set up the base classes pointers.
-Each class structure has a list of pointers to the base class structures.
-This function fills them.
-It cannot be done at compile time, as this will not work with hireachies
-spread over more than one swig file. 
-Therefore it must be done at runtime, querying the SWIG type system.
-*/
-SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
-{
-  int i=0;
-  swig_module_info* module=SWIG_GetModule(L);
-  for(i=0;clss->base_names[i];i++)
-  {
-    if (clss->bases[i]==0) /* not found yet */
-    {
-      /* lookup and cache the base class */
-      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
-      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
-    }
-  }	
-}
-
-/* performs the entire class registration process */
-SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
-{
-  /*  add its constructor to module with the name of the class
-  so you can do MyClass(...) as well as new_MyClass(...)
-  BUT only if a constructor is defined
-  (this overcomes the problem of pure virtual classes without constructors)*/
-  if (clss->constructor)
-    SWIG_Lua_add_function(L,clss->name,clss->constructor);
-
-  SWIG_Lua_get_class_registry(L);  /* get the registry */
-  lua_pushstring(L,clss->name);  /* get the name */
-  lua_newtable(L);    /* create the metatable */
-  /* add string of class name called ".type" */
-  lua_pushstring(L,".type");
-  lua_pushstring(L,clss->name);
-  lua_rawset(L,-3);
-  /* add a table called ".get" */
-  lua_pushstring(L,".get");
-  lua_newtable(L);
-  lua_rawset(L,-3);
-  /* add a table called ".set" */
-  lua_pushstring(L,".set");
-  lua_newtable(L);
-  lua_rawset(L,-3);
-  /* add a table called ".fn" */
-  lua_pushstring(L,".fn");
-  lua_newtable(L);
-  lua_rawset(L,-3);
-  /* add accessor fns for using the .get,.set&.fn */
-  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
-  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
-  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
-  /* add it */
-  lua_rawset(L,-3);  /* metatable into registry */
-  lua_pop(L,1);      /* tidy stack (remove registry) */
-
-  SWIG_Lua_get_class_metatable(L,clss->name);
-  SWIG_Lua_add_class_details(L,clss);  /* recursive adding of details (atts & ops) */
-  lua_pop(L,1);      /* tidy stack (remove class metatable) */
-}
-
-/* -----------------------------------------------------------------------------
- * Class/structure conversion fns
- * ----------------------------------------------------------------------------- */
-
-/* helper to add metatable to new lua object */
-SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
-{
-  if (type->clientdata)  /* there is clientdata: so add the metatable */
-  {
-    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
-    if (lua_istable(L,-1))
-    {
-      lua_setmetatable(L,-2);
-    }
-    else
-    {
-      lua_pop(L,1);
-    }
-  }
-}
-
-/* pushes a new object into the lua stack */
-SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
-{
-  swig_lua_userdata* usr;
-  if (!ptr){
-    lua_pushnil(L);
-    return;
-  }
-  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
-  usr->ptr=ptr;  /* set the ptr */
-  usr->type=type;
-  usr->own=own;
-  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
-}
-
-/* takes a object from the lua stack & converts it into an object of the correct type
- (if possible) */
-SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
-{
-  swig_lua_userdata* usr;
-  swig_cast_info *cast;
-  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
-  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
-  if (usr)
-  {
-    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
-    {
-        usr->own=0;
-    }
-    if (!type)            /* special cast void*, no casting fn */
-    {
-      *ptr=usr->ptr;
-      return SWIG_OK; /* ok */
-    }
-    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
-    if (cast)
-    {
-      int newmemory = 0;
-      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
-      assert(!newmemory); /* newmemory handling not yet implemented */
-      return SWIG_OK;  /* ok */
-    }
-  }
-  return SWIG_ERROR;  /* error */
-}
-
-SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
-       int argnum,const char* func_name){
-  void* result;
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
-    lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
-      func_name,(type && type->str)?type->str:"void*",argnum);
-    lua_error(L);
-  }
-  return result;
-}
-
-/* pushes a packed userdata. user for member fn pointers only */
-SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
-{
-  swig_lua_rawdata* raw;
-  assert(ptr); /* not acceptable to pass in a NULL value */
-  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
-  raw->type=type;
-  raw->own=0;
-  memcpy(raw->data,ptr,size); /* copy the data */
-  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
-}
-    
-/* converts a packed userdata. user for member fn pointers only */
-SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
-{
-  swig_lua_rawdata* raw;
-  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
-  if (!raw) return SWIG_ERROR;  /* error */
-  if (type==0 || type==raw->type) /* void* or identical type */
-  {
-    memcpy(ptr,raw->data,size); /* copy it */
-    return SWIG_OK; /* ok */
-  }
-  return SWIG_ERROR;  /* error */
-}
-
-/* a function to get the typestring of a piece of data */
-SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
-{
-  swig_lua_userdata* usr;
-  if (lua_isuserdata(L,tp))
-  {
-    usr=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
-    if (usr && usr->type && usr->type->str)
-      return usr->type->str;
-    return "userdata (unknown type)";
-  }
-  return lua_typename(L,lua_type(L,tp));
-}
-
-/* lua callable function to get the userdata's type */
-SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
-{
-  lua_pushstring(L,SWIG_Lua_typename(L,1));
-  return 1;
-}
-
-/* lua callable function to compare userdata's value
-the issue is that two userdata may point to the same thing
-but to lua, they are different objects */
-SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
-{
-  int result;
-  swig_lua_userdata *usr1,*usr2;
-  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
-    return 0;  /* nil reply */
-  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
-  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
-  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
-  result=(usr1->ptr==usr2->ptr);
-   lua_pushboolean(L,result);
-  return 1;
-}
-
-/* -----------------------------------------------------------------------------
- * global variable support code: class/struct typemap functions
- * ----------------------------------------------------------------------------- */
-
-/* Install Constants */
-SWIGINTERN void
-SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
-  int i;
-  for (i = 0; constants[i].type; i++) {
-    switch(constants[i].type) {
-    case SWIG_LUA_INT:
-      lua_pushstring(L,constants[i].name);
-      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
-      lua_rawset(L,-3);
-      break;
-    case SWIG_LUA_FLOAT:
-      lua_pushstring(L,constants[i].name);
-      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
-      lua_rawset(L,-3);
-      break;
-    case SWIG_LUA_CHAR:
-      lua_pushstring(L,constants[i].name);
-      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
-      lua_rawset(L,-3);
-      break;
-    case SWIG_LUA_STRING:
-      lua_pushstring(L,constants[i].name);
-      lua_pushstring(L,(char *) constants[i].pvalue);
-      lua_rawset(L,-3);
-      break;
-    case SWIG_LUA_POINTER:
-      lua_pushstring(L,constants[i].name);
-      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
-      lua_rawset(L,-3);
-      break;
-    case SWIG_LUA_BINARY:
-      lua_pushstring(L,constants[i].name);
-      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
-      lua_rawset(L,-3);
-      break;
-    default:
-      break;
-    }
-  }
-}
-
-/* -----------------------------------------------------------------------------
- * executing lua code from within the wrapper
- * ----------------------------------------------------------------------------- */
-
-#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
-#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
-#endif
-/* Executes a C string in Lua a really simple way of calling lua from C
-Unfortunately lua keeps changing its API's, so we need a conditional compile
-In lua 5.0.X its lua_dostring()
-In lua 5.1.X its luaL_dostring()
-*/
-SWIGINTERN int 
-SWIG_Lua_dostring(lua_State *L, const char* str) {
-  int ok,top;
-  if (str==0 || str[0]==0) return 0; /* nothing to do */
-  top=lua_gettop(L); /* save stack */
-#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
-  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
-#else
-  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
-#endif
-  if (ok!=0) {
-    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
-  }
-  lua_settop(L,top); /* restore the stack */
-  return ok;
-}    
-
-#ifdef __cplusplus
-}
-#endif
-
-/* ------------------------------ end luarun.swg  ------------------------------ */
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_EAnimate swig_types[0]
-#define SWIGTYPE_p_EVOType swig_types[1]
-#define SWIGTYPE_p_LLSafeHandleT_LLObjectSelection_t swig_types[2]
-#define SWIGTYPE_p_LLSimInfo swig_types[3]
-#define SWIGTYPE_p_LLUUID swig_types[4]
-#define SWIGTYPE_p_LLVOAvatar swig_types[5]
-#define SWIGTYPE_p_LLViewerRegion swig_types[6]
-#define SWIGTYPE_p_LLWearable swig_types[7]
-#define SWIGTYPE_p_LuaAgent swig_types[8]
-#define SWIGTYPE_p_LuaWorldMap swig_types[9]
-#define SWIGTYPE_p_child_list_t swig_types[10]
-#define SWIGTYPE_p_const_child_list_t swig_types[11]
-#define SWIGTYPE_p_double swig_types[12]
-#define SWIGTYPE_p_eLayoutOrientation swig_types[13]
-#define SWIGTYPE_p_eObjectPartitions swig_types[14]
-#define SWIGTYPE_p_e_action_type swig_types[15]
-#define SWIGTYPE_p_e_anim_request swig_types[16]
-#define SWIGTYPE_p_e_camera_modes swig_types[17]
-#define SWIGTYPE_p_e_camera_position swig_types[18]
-#define SWIGTYPE_p_e_grid_mode swig_types[19]
-#define SWIGTYPE_p_e_object_update_type swig_types[20]
-#define SWIGTYPE_p_e_selection_type swig_types[21]
-#define SWIGTYPE_p_e_send_type swig_types[22]
-#define SWIGTYPE_p_float swig_types[23]
-#define SWIGTYPE_p_int swig_types[24]
-#define SWIGTYPE_p_iterator swig_types[25]
-#define SWIGTYPE_p_list_t swig_types[26]
-#define SWIGTYPE_p_long_long swig_types[27]
-#define SWIGTYPE_p_root_iterator swig_types[28]
-#define SWIGTYPE_p_root_object_iterator swig_types[29]
-#define SWIGTYPE_p_short swig_types[30]
-#define SWIGTYPE_p_signed_char swig_types[31]
-#define SWIGTYPE_p_skip_list_t swig_types[32]
-#define SWIGTYPE_p_std__string swig_types[33]
-#define SWIGTYPE_p_unsigned_char swig_types[34]
-#define SWIGTYPE_p_unsigned_int swig_types[35]
-#define SWIGTYPE_p_unsigned_long_long swig_types[36]
-#define SWIGTYPE_p_unsigned_short swig_types[37]
-#define SWIGTYPE_p_valid_iterator swig_types[38]
-#define SWIGTYPE_p_valid_root_iterator swig_types[39]
-#define SWIGTYPE_p_vobj_list_t swig_types[40]
-#define SWIGTYPE_p_wchar_t swig_types[41]
-static swig_type_info *swig_types[43];
-static swig_module_info swig_module = {swig_types, 42, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#define SWIG_name      "SL"
-#define SWIG_init      luaopen_SL
-#define SWIG_init_user luaopen_SL_user
-
-#define SWIG_LUACODE   luaopen_SL_luacode
-
-
-namespace swig {
-typedef struct{} LANGUAGE_OBJ;
-}
+//There is currently no way to insert text to the very start of a file generated by 
+//SWIG. This results in compile errors with Visual Studio.
 
+//Begin dumb workaround.
 
 #include "llviewerprecompiledheaders.h"
-#include "stdtypes.h"
-//#include "SLua.h"
-#include "llfloater.h"
-#include "lllineeditor.h"
-#include "llpanel.h"
-#include "llbutton.h"
-#include "lliconctrl.h"
-#include "LuaBase_f.h"
-#include "LuaAvatar_f.h"
-#include "LuaAgent_f.h"
-#include "llprimitive.h"
-#include "llviewerobject.h"
-#include "llvovolume.h"
-#include "llagent.h"
-#include "llselectmgr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-static int _wrap_SendChat__SWIG_0(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  bool arg2 ;
-  
-  SWIG_check_num_args("LuaSendChat",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaSendChat",1,"char const *");
-  if(!lua_isboolean(L,2)) SWIG_fail_arg("LuaSendChat",2,"bool");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (lua_toboolean(L, 2)!=0);
-  LuaSendChat((char const *)arg1,arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_SendChat__SWIG_1(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaSendChat",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaSendChat",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaSendChat((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_SendChat(lua_State* L) {
-  int argc;
-  int argv[3]={
-    1,2,3
-  };
-  
-  argc = lua_gettop(L);
-  if (argc == 1) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      return _wrap_SendChat__SWIG_1(L);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isboolean(L,argv[1]);
-      }
-      if (_v) {
-        return _wrap_SendChat__SWIG_0(L);
-      }
-    }
-  }
-  
-  lua_pushstring(L,"Wrong arguments for overloaded function 'SendChat'\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    LuaSendChat(char const *,bool)\n"
-    "    LuaSendChat(char const *)\n");
-  lua_error(L);return 0;
-}
-
-
-static int _wrap_print(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaPrint",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaPrint",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaPrint((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAlert(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaAlert",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaAlert",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaAlert((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_GetCWD(lua_State* L) {
-  int SWIG_arg = 0;
-  char *result = 0 ;
-  
-  SWIG_check_num_args("LuaGetCWD",0,0)
-  result = (char *)LuaGetCWD();
-  lua_pushstring(L,(const char*)result); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_RegionFromName(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  LLViewerRegion *result = 0 ;
-  
-  SWIG_check_num_args("LuaRegionFromName",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaRegionFromName",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  result = (LLViewerRegion *)LuaRegionFromName((char const *)arg1);
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LLViewerRegion,0); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_GetCurrentRegion(lua_State* L) {
-  int SWIG_arg = 0;
-  LLViewerRegion *result = 0 ;
-  
-  SWIG_check_num_args("LuaGetCurrentRegion",0,0)
-  result = (LLViewerRegion *)LuaGetCurrentRegion();
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LLViewerRegion,0); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_error(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaError",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaError",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaError((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaTouch(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaTouch",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaTouch",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaTouch((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_say__SWIG_0(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaSay",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaSay",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaSay",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  LuaSay((char const *)arg1,(char const *)arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_say__SWIG_1(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaSay",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaSay",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaSay((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_say(lua_State* L) {
-  int argc;
-  int argv[3]={
-    1,2,3
-  };
-  
-  argc = lua_gettop(L);
-  if (argc == 1) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      return _wrap_say__SWIG_1(L);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isstring(L,argv[1]);
-      }
-      if (_v) {
-        return _wrap_say__SWIG_0(L);
-      }
-    }
-  }
-  
-  lua_pushstring(L,"Wrong arguments for overloaded function 'say'\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    LuaSay(char const *,char const *)\n"
-    "    LuaSay(char const *)\n");
-  lua_error(L);return 0;
-}
-
-
-static int _wrap_shout__SWIG_0(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaShout",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaShout",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaShout",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  LuaShout((char const *)arg1,(char const *)arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_shout__SWIG_1(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaShout",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaShout",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaShout((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_shout(lua_State* L) {
-  int argc;
-  int argv[3]={
-    1,2,3
-  };
-  
-  argc = lua_gettop(L);
-  if (argc == 1) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      return _wrap_shout__SWIG_1(L);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isstring(L,argv[1]);
-      }
-      if (_v) {
-        return _wrap_shout__SWIG_0(L);
-      }
-    }
-  }
-  
-  lua_pushstring(L,"Wrong arguments for overloaded function 'shout'\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    LuaShout(char const *,char const *)\n"
-    "    LuaShout(char const *)\n");
-  lua_error(L);return 0;
-}
-
-
-static int _wrap_whisper__SWIG_0(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaWhisper",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaWhisper",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaWhisper",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  LuaWhisper((char const *)arg1,(char const *)arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_whisper__SWIG_1(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaWhisper",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaWhisper",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaWhisper((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_whisper(lua_State* L) {
-  int argc;
-  int argv[3]={
-    1,2,3
-  };
-  
-  argc = lua_gettop(L);
-  if (argc == 1) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      return _wrap_whisper__SWIG_1(L);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isstring(L,argv[1]);
-      }
-      if (_v) {
-        return _wrap_whisper__SWIG_0(L);
-      }
-    }
-  }
-  
-  lua_pushstring(L,"Wrong arguments for overloaded function 'whisper'\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    LuaWhisper(char const *,char const *)\n"
-    "    LuaWhisper(char const *)\n");
-  lua_error(L);return 0;
-}
-
-
-static int _wrap_LuaSendRawChat(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  bool arg3 ;
-  S32 arg4 ;
-  
-  SWIG_check_num_args("LuaSendRawChat",4,4)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaSendRawChat",1,"char const *");
-  if(!lua_isnumber(L,2)) SWIG_fail_arg("LuaSendRawChat",2,"int");
-  if(!lua_isboolean(L,3)) SWIG_fail_arg("LuaSendRawChat",3,"bool");
-  if(!lua_isnumber(L,4)) SWIG_fail_arg("LuaSendRawChat",4,"S32");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (int)lua_tonumber(L, 2);
-  arg3 = (lua_toboolean(L, 3)!=0);
-  arg4 = (S32)lua_tonumber(L, 4);
-  LuaSendRawChat((char const *)arg1,arg2,arg3,arg4);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_tp__SWIG_0(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  
-  SWIG_check_num_args("Lua_tp",4,4)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("Lua_tp",1,"char const *");
-  if(!lua_isnumber(L,2)) SWIG_fail_arg("Lua_tp",2,"int");
-  if(!lua_isnumber(L,3)) SWIG_fail_arg("Lua_tp",3,"int");
-  if(!lua_isnumber(L,4)) SWIG_fail_arg("Lua_tp",4,"int");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (int)lua_tonumber(L, 2);
-  arg3 = (int)lua_tonumber(L, 3);
-  arg4 = (int)lua_tonumber(L, 4);
-  Lua_tp((char const *)arg1,arg2,arg3,arg4);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_tp__SWIG_1(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  
-  SWIG_check_num_args("Lua_tp",3,3)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("Lua_tp",1,"char const *");
-  if(!lua_isnumber(L,2)) SWIG_fail_arg("Lua_tp",2,"int");
-  if(!lua_isnumber(L,3)) SWIG_fail_arg("Lua_tp",3,"int");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (int)lua_tonumber(L, 2);
-  arg3 = (int)lua_tonumber(L, 3);
-  Lua_tp((char const *)arg1,arg2,arg3);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_tp__SWIG_2(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  
-  SWIG_check_num_args("Lua_tp",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("Lua_tp",1,"char const *");
-  if(!lua_isnumber(L,2)) SWIG_fail_arg("Lua_tp",2,"int");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (int)lua_tonumber(L, 2);
-  Lua_tp((char const *)arg1,arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_tp__SWIG_3(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("Lua_tp",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("Lua_tp",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  Lua_tp((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_tp(lua_State* L) {
-  int argc;
-  int argv[5]={
-    1,2,3,4,5
-  };
-  
-  argc = lua_gettop(L);
-  if (argc == 1) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      return _wrap_tp__SWIG_3(L);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isnumber(L,argv[1]);
-      }
-      if (_v) {
-        return _wrap_tp__SWIG_2(L);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isnumber(L,argv[1]);
-      }
-      if (_v) {
-        {
-          _v = lua_isnumber(L,argv[2]);
-        }
-        if (_v) {
-          return _wrap_tp__SWIG_1(L);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    {
-      _v = lua_isstring(L,argv[0]);
-    }
-    if (_v) {
-      {
-        _v = lua_isnumber(L,argv[1]);
-      }
-      if (_v) {
-        {
-          _v = lua_isnumber(L,argv[2]);
-        }
-        if (_v) {
-          {
-            _v = lua_isnumber(L,argv[3]);
-          }
-          if (_v) {
-            return _wrap_tp__SWIG_0(L);
-          }
-        }
-      }
-    }
-  }
-  
-  lua_pushstring(L,"Wrong arguments for overloaded function 'tp'\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    Lua_tp(char const *,int,int,int)\n"
-    "    Lua_tp(char const *,int,int)\n"
-    "    Lua_tp(char const *,int)\n"
-    "    Lua_tp(char const *)\n");
-  lua_error(L);return 0;
-}
-
-
-static int _wrap_exists(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  bool result;
-  
-  SWIG_check_num_args("Lua_exists",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("Lua_exists",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  result = (bool)Lua_exists((char const *)arg1);
-  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_getLuaFolder(lua_State* L) {
-  int SWIG_arg = 0;
-  std::string result;
-  
-  SWIG_check_num_args("getLuaFolder",0,0)
-  result = getLuaFolder();
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_toLuaString(lua_State* L) {
-  int SWIG_arg = 0;
-  F32 arg1 ;
-  std::string result;
-  
-  SWIG_check_num_args("toLuaString",1,1)
-  if(!lua_isnumber(L,1)) SWIG_fail_arg("toLuaString",1,"F32");
-  arg1 = (F32)lua_tonumber(L, 1);
-  result = toLuaString(arg1);
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_gAllowWorldMap_set(lua_State* L) {
-  int SWIG_arg = 0;
-  bool arg1 ;
-  
-  SWIG_check_num_args("gAllowWorldMap",1,1)
-  if(!lua_isboolean(L,1)) SWIG_fail_arg("gAllowWorldMap",1,"bool");
-  arg1 = (lua_toboolean(L, 1)!=0);
-  gAllowWorldMap = arg1;
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_gAllowWorldMap_get(lua_State* L) {
-  int SWIG_arg = 0;
-  bool result;
-  
-  SWIG_check_num_args("gAllowWorldMap",0,0)
-  result = (bool)gAllowWorldMap;
-  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaDumpVisualParams(lua_State* L) {
-  int SWIG_arg = 0;
-  
-  SWIG_check_num_args("LuaDumpVisualParams",0,0)
-  LuaDumpVisualParams();
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaDumpVisualParamsToLuaCode(lua_State* L) {
-  int SWIG_arg = 0;
-  std::string result;
-  
-  SWIG_check_num_args("LuaDumpVisualParamsToLuaCode",0,0)
-  result = LuaDumpVisualParamsToLuaCode();
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_getParamDefaultWeight(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double result;
-  
-  SWIG_check_num_args("getParamDefaultWeight",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("getParamDefaultWeight",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("getParamDefaultWeight",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  result = (double)getParamDefaultWeight((char const *)arg1,(char const *)arg2);
-  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_getParamCurrentWeight(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double result;
-  
-  SWIG_check_num_args("getParamCurrentWeight",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("getParamCurrentWeight",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("getParamCurrentWeight",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  result = (double)getParamCurrentWeight((char const *)arg1,(char const *)arg2);
-  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_getParamMax(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double result;
-  
-  SWIG_check_num_args("getParamMax",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("getParamMax",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("getParamMax",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  result = (double)getParamMax((char const *)arg1,(char const *)arg2);
-  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_getParamMin(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double result;
-  
-  SWIG_check_num_args("getParamMin",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("getParamMin",1,"char const *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("getParamMin",2,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  result = (double)getParamMin((char const *)arg1,(char const *)arg2);
-  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_setParamOnSelf(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  double arg2 ;
-  
-  SWIG_check_num_args("setParamOnSelf",2,2)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("setParamOnSelf",1,"char const *");
-  if(!lua_isnumber(L,2)) SWIG_fail_arg("setParamOnSelf",2,"double");
-  arg1 = (char *)lua_tostring(L, 1);
-  arg2 = (double)lua_tonumber(L, 2);
-  setParamOnSelf((char const *)arg1,arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_wear(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaWear",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaWear",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  LuaWear((char const *)arg1);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_RemoveAllWearables(lua_State* L) {
-  int SWIG_arg = 0;
-  
-  SWIG_check_num_args("LuaRemoveAllWearables",0,0)
-  LuaRemoveAllWearables();
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaSaveWearable(lua_State* L) {
-  int SWIG_arg = 0;
-  LLWearable *arg1 = (LLWearable *) 0 ;
-  bool result;
-  
-  SWIG_check_num_args("LuaSaveWearable",1,1)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaSaveWearable",1,"LLWearable *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LLWearable,0))){
-    SWIG_fail_ptr("LuaSaveWearable",1,SWIGTYPE_p_LLWearable);
-  }
-  
-  result = (bool)LuaSaveWearable(arg1);
-  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaLoadWearable(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  LLWearable *result = 0 ;
-  
-  SWIG_check_num_args("LuaLoadWearable",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaLoadWearable",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  result = (LLWearable *)LuaLoadWearable((char const *)arg1);
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LLWearable,0); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_setTEImage(lua_State* L) {
-  int SWIG_arg = 0;
-  int arg1 ;
-  char *arg2 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaSetTEImage",2,2)
-  if(!lua_isnumber(L,1)) SWIG_fail_arg("LuaSetTEImage",1,"int");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaSetTEImage",2,"char const *");
-  arg1 = (int)lua_tonumber(L, 1);
-  arg2 = (char *)lua_tostring(L, 2);
-  LuaSetTEImage(arg1,(char const *)arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAgent_LuaGetFullName(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *arg1 = (LuaAgent *) 0 ;
-  std::string result;
-  
-  SWIG_check_num_args("LuaGetFullName",1,1)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaGetFullName",1,"LuaAgent *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaAgent,0))){
-    SWIG_fail_ptr("LuaAgent_LuaGetFullName",1,SWIGTYPE_p_LuaAgent);
-  }
-  
-  result = (arg1)->LuaGetFullName();
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAgent_LuaGetID(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *arg1 = (LuaAgent *) 0 ;
-  std::string result;
-  
-  SWIG_check_num_args("LuaGetID",1,1)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaGetID",1,"LuaAgent *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaAgent,0))){
-    SWIG_fail_ptr("LuaAgent_LuaGetID",1,SWIGTYPE_p_LuaAgent);
-  }
-  
-  result = (arg1)->LuaGetID();
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAgent_LuaSetTyping(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *arg1 = (LuaAgent *) 0 ;
-  bool arg2 ;
-  
-  SWIG_check_num_args("LuaSetTyping",2,2)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaSetTyping",1,"LuaAgent *");
-  if(!lua_isboolean(L,2)) SWIG_fail_arg("LuaSetTyping",2,"bool");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaAgent,0))){
-    SWIG_fail_ptr("LuaAgent_LuaSetTyping",1,SWIGTYPE_p_LuaAgent);
-  }
-  
-  arg2 = (lua_toboolean(L, 2)!=0);
-  (arg1)->LuaSetTyping(arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAgent_LuaGetTyping(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *arg1 = (LuaAgent *) 0 ;
-  bool result;
-  
-  SWIG_check_num_args("LuaGetTyping",1,1)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaGetTyping",1,"LuaAgent *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaAgent,0))){
-    SWIG_fail_ptr("LuaAgent_LuaGetTyping",1,SWIGTYPE_p_LuaAgent);
-  }
-  
-  result = (bool)(arg1)->LuaGetTyping();
-  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaAgent_LuaFollow(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *arg1 = (LuaAgent *) 0 ;
-  char *arg2 = (char *) 0 ;
-  
-  SWIG_check_num_args("LuaFollow",2,2)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaFollow",1,"LuaAgent *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaFollow",2,"char const *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaAgent,0))){
-    SWIG_fail_ptr("LuaAgent_LuaFollow",1,SWIGTYPE_p_LuaAgent);
-  }
-  
-  arg2 = (char *)lua_tostring(L, 2);
-  (arg1)->LuaFollow((char const *)arg2);
-  
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_new_LuaAgent(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaAgent *result = 0 ;
-  
-  SWIG_check_num_args("LuaAgent::LuaAgent",0,0)
-  result = (LuaAgent *)new LuaAgent();
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LuaAgent,1); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static void swig_delete_LuaAgent(void *obj) {
-LuaAgent *arg1 = (LuaAgent *) obj;
-delete arg1;
-}
-static swig_lua_method swig_LuaAgent_methods[] = {
-    {"LuaGetFullName", _wrap_LuaAgent_LuaGetFullName}, 
-    {"LuaGetID", _wrap_LuaAgent_LuaGetID}, 
-    {"LuaSetTyping", _wrap_LuaAgent_LuaSetTyping}, 
-    {"LuaGetTyping", _wrap_LuaAgent_LuaGetTyping}, 
-    {"LuaFollow", _wrap_LuaAgent_LuaFollow}, 
-    {0,0}
-};
-static swig_lua_attribute swig_LuaAgent_attributes[] = {
-    {0,0,0}
-};
-static swig_lua_class *swig_LuaAgent_bases[] = {0};
-static const char *swig_LuaAgent_base_names[] = {0};
-static swig_lua_class _wrap_class_LuaAgent = { "LuaAgent", &SWIGTYPE_p_LuaAgent,_wrap_new_LuaAgent, swig_delete_LuaAgent, swig_LuaAgent_methods, swig_LuaAgent_attributes, swig_LuaAgent_bases, swig_LuaAgent_base_names };
-
-static int _wrap_LuaWorldMap_LuaGetSimFromName(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaWorldMap *arg1 = (LuaWorldMap *) 0 ;
-  char *arg2 = (char *) 0 ;
-  LLSimInfo *result = 0 ;
-  
-  SWIG_check_num_args("LuaGetSimFromName",2,2)
-  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LuaGetSimFromName",1,"LuaWorldMap *");
-  if(!lua_isstring(L,2)) SWIG_fail_arg("LuaGetSimFromName",2,"char const *");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LuaWorldMap,0))){
-    SWIG_fail_ptr("LuaWorldMap_LuaGetSimFromName",1,SWIGTYPE_p_LuaWorldMap);
-  }
-  
-  arg2 = (char *)lua_tostring(L, 2);
-  result = (LLSimInfo *)(arg1)->LuaGetSimFromName((char const *)arg2);
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LLSimInfo,0); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_new_LuaWorldMap(lua_State* L) {
-  int SWIG_arg = 0;
-  LuaWorldMap *result = 0 ;
-  
-  SWIG_check_num_args("LuaWorldMap::LuaWorldMap",0,0)
-  result = (LuaWorldMap *)new LuaWorldMap();
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LuaWorldMap,1); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static void swig_delete_LuaWorldMap(void *obj) {
-LuaWorldMap *arg1 = (LuaWorldMap *) obj;
-delete arg1;
-}
-static swig_lua_method swig_LuaWorldMap_methods[] = {
-    {"LuaGetSimFromName", _wrap_LuaWorldMap_LuaGetSimFromName}, 
-    {0,0}
-};
-static swig_lua_attribute swig_LuaWorldMap_attributes[] = {
-    {0,0,0}
-};
-static swig_lua_class *swig_LuaWorldMap_bases[] = {0};
-static const char *swig_LuaWorldMap_base_names[] = {0};
-static swig_lua_class _wrap_class_LuaWorldMap = { "LuaWorldMap", &SWIGTYPE_p_LuaWorldMap,_wrap_new_LuaWorldMap, swig_delete_LuaWorldMap, swig_LuaWorldMap_methods, swig_LuaWorldMap_attributes, swig_LuaWorldMap_bases, swig_LuaWorldMap_base_names };
-
-static int _wrap_key2name(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  std::string result;
-  
-  SWIG_check_num_args("LuaFindAvatarName",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaFindAvatarName",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  result = LuaFindAvatarName((char const *)arg1);
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_name2key(lua_State* L) {
-  int SWIG_arg = 0;
-  char *arg1 = (char *) 0 ;
-  std::string result;
-  
-  SWIG_check_num_args("LuaFindAvatarKey",1,1)
-  if(!lua_isstring(L,1)) SWIG_fail_arg("LuaFindAvatarKey",1,"char const *");
-  arg1 = (char *)lua_tostring(L, 1);
-  result = LuaFindAvatarKey((char const *)arg1);
-  {
-    std::string * resultptr = new std::string((const std::string &) result);
-    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__string,1); SWIG_arg++;
-  }
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-static int _wrap_LuaGetAvatar(lua_State* L) {
-  int SWIG_arg = 0;
-  LLUUID *arg1 = 0 ;
-  LLVOAvatar *result = 0 ;
-  
-  SWIG_check_num_args("LuaGetAvatar",1,1)
-  if(!lua_isuserdata(L,1)) SWIG_fail_arg("LuaGetAvatar",1,"LLUUID const &");
-  
-  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_LLUUID,0))){
-    SWIG_fail_ptr("LuaGetAvatar",1,SWIGTYPE_p_LLUUID);
-  }
-  
-  result = (LLVOAvatar *)LuaGetAvatar((LLUUID const &)*arg1);
-  SWIG_NewPointerObj(L,result,SWIGTYPE_p_LLVOAvatar,0); SWIG_arg++; 
-  return SWIG_arg;
-  
-  if(0) SWIG_fail;
-  
-fail:
-  lua_error(L);
-  return SWIG_arg;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-static const struct luaL_reg swig_commands[] = {
-    { "SendChat",_wrap_SendChat},
-    { "print", _wrap_print},
-    { "LuaAlert", _wrap_LuaAlert},
-    { "GetCWD", _wrap_GetCWD},
-    { "RegionFromName", _wrap_RegionFromName},
-    { "GetCurrentRegion", _wrap_GetCurrentRegion},
-    { "error", _wrap_error},
-    { "LuaTouch", _wrap_LuaTouch},
-    { "say",_wrap_say},
-    { "shout",_wrap_shout},
-    { "whisper",_wrap_whisper},
-    { "LuaSendRawChat", _wrap_LuaSendRawChat},
-    { "tp",_wrap_tp},
-    { "exists", _wrap_exists},
-    { "getLuaFolder", _wrap_getLuaFolder},
-    { "toLuaString", _wrap_toLuaString},
-    { "LuaDumpVisualParams", _wrap_LuaDumpVisualParams},
-    { "LuaDumpVisualParamsToLuaCode", _wrap_LuaDumpVisualParamsToLuaCode},
-    { "getParamDefaultWeight", _wrap_getParamDefaultWeight},
-    { "getParamCurrentWeight", _wrap_getParamCurrentWeight},
-    { "getParamMax", _wrap_getParamMax},
-    { "getParamMin", _wrap_getParamMin},
-    { "setParamOnSelf", _wrap_setParamOnSelf},
-    { "wear", _wrap_wear},
-    { "RemoveAllWearables", _wrap_RemoveAllWearables},
-    { "LuaSaveWearable", _wrap_LuaSaveWearable},
-    { "LuaLoadWearable", _wrap_LuaLoadWearable},
-    { "setTEImage", _wrap_setTEImage},
-    { "key2name", _wrap_key2name},
-    { "name2key", _wrap_name2key},
-    { "LuaGetAvatar", _wrap_LuaGetAvatar},
-    {0,0}
-};
-
-static swig_lua_var_info swig_variables[] = {
-    { "gAllowWorldMap", _wrap_gAllowWorldMap_get, _wrap_gAllowWorldMap_set },
-    {0,0,0}
-};
-
-static swig_lua_const_info swig_constants[] = {
-    {0,0,0,0,0,0}
-};
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_EAnimate = {"_p_EAnimate", "EAnimate *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_EVOType = {"_p_EVOType", "EVOType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLSafeHandleT_LLObjectSelection_t = {"_p_LLSafeHandleT_LLObjectSelection_t", "LLSafeHandle< LLObjectSelection > *|LLObjectSelectionHandle *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLSimInfo = {"_p_LLSimInfo", "LLSimInfo *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLUUID = {"_p_LLUUID", "LLUUID *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLVOAvatar = {"_p_LLVOAvatar", "LLVOAvatar *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLViewerRegion = {"_p_LLViewerRegion", "LLViewerRegion *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LLWearable = {"_p_LLWearable", "LLWearable *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_LuaAgent = {"_p_LuaAgent", "LuaAgent *", 0, 0, (void*)&_wrap_class_LuaAgent, 0};
-static swig_type_info _swigt__p_LuaWorldMap = {"_p_LuaWorldMap", "LuaWorldMap *", 0, 0, (void*)&_wrap_class_LuaWorldMap, 0};
-static swig_type_info _swigt__p_child_list_t = {"_p_child_list_t", "child_list_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_const_child_list_t = {"_p_const_child_list_t", "const_child_list_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_double = {"_p_double", "double *|F64 *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_eLayoutOrientation = {"_p_eLayoutOrientation", "eLayoutOrientation *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_eObjectPartitions = {"_p_eObjectPartitions", "eObjectPartitions *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_action_type = {"_p_e_action_type", "enum e_action_type *|EActionType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_anim_request = {"_p_e_anim_request", "enum e_anim_request *|EAnimRequest *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_camera_modes = {"_p_e_camera_modes", "enum e_camera_modes *|ECameraMode *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_camera_position = {"_p_e_camera_position", "enum e_camera_position *|ECameraPosition *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_grid_mode = {"_p_e_grid_mode", "enum e_grid_mode *|EGridMode *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_object_update_type = {"_p_e_object_update_type", "enum e_object_update_type *|EObjectUpdateType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_selection_type = {"_p_e_selection_type", "enum e_selection_type *|ESelectType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_e_send_type = {"_p_e_send_type", "enum e_send_type *|ESendType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_float = {"_p_float", "float *|F32 *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "BOOL *|int *|S32 *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_list_t = {"_p_list_t", "list_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_long_long = {"_p_long_long", "S64 *|long long *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_root_iterator = {"_p_root_iterator", "root_iterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_root_object_iterator = {"_p_root_object_iterator", "root_object_iterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_short = {"_p_short", "S16 *|short *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|S8 *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_skip_list_t = {"_p_skip_list_t", "skip_list_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|KEY *|U8 *|LLPCode *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *|U32 *|MASK *|TPACKETID *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "unsigned long long *|U64 *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "U16 *|unsigned short *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_valid_iterator = {"_p_valid_iterator", "valid_iterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_valid_root_iterator = {"_p_valid_root_iterator", "valid_root_iterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vobj_list_t = {"_p_vobj_list_t", "vobj_list_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_wchar_t = {"_p_wchar_t", "llwchar *|wchar_t *", 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p_EAnimate,
-  &_swigt__p_EVOType,
-  &_swigt__p_LLSafeHandleT_LLObjectSelection_t,
-  &_swigt__p_LLSimInfo,
-  &_swigt__p_LLUUID,
-  &_swigt__p_LLVOAvatar,
-  &_swigt__p_LLViewerRegion,
-  &_swigt__p_LLWearable,
-  &_swigt__p_LuaAgent,
-  &_swigt__p_LuaWorldMap,
-  &_swigt__p_child_list_t,
-  &_swigt__p_const_child_list_t,
-  &_swigt__p_double,
-  &_swigt__p_eLayoutOrientation,
-  &_swigt__p_eObjectPartitions,
-  &_swigt__p_e_action_type,
-  &_swigt__p_e_anim_request,
-  &_swigt__p_e_camera_modes,
-  &_swigt__p_e_camera_position,
-  &_swigt__p_e_grid_mode,
-  &_swigt__p_e_object_update_type,
-  &_swigt__p_e_selection_type,
-  &_swigt__p_e_send_type,
-  &_swigt__p_float,
-  &_swigt__p_int,
-  &_swigt__p_iterator,
-  &_swigt__p_list_t,
-  &_swigt__p_long_long,
-  &_swigt__p_root_iterator,
-  &_swigt__p_root_object_iterator,
-  &_swigt__p_short,
-  &_swigt__p_signed_char,
-  &_swigt__p_skip_list_t,
-  &_swigt__p_std__string,
-  &_swigt__p_unsigned_char,
-  &_swigt__p_unsigned_int,
-  &_swigt__p_unsigned_long_long,
-  &_swigt__p_unsigned_short,
-  &_swigt__p_valid_iterator,
-  &_swigt__p_valid_root_iterator,
-  &_swigt__p_vobj_list_t,
-  &_swigt__p_wchar_t,
-};
-
-static swig_cast_info _swigc__p_EAnimate[] = {  {&_swigt__p_EAnimate, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_EVOType[] = {  {&_swigt__p_EVOType, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLSafeHandleT_LLObjectSelection_t[] = {  {&_swigt__p_LLSafeHandleT_LLObjectSelection_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLSimInfo[] = {  {&_swigt__p_LLSimInfo, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLUUID[] = {  {&_swigt__p_LLUUID, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLVOAvatar[] = {  {&_swigt__p_LLVOAvatar, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLViewerRegion[] = {  {&_swigt__p_LLViewerRegion, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LLWearable[] = {  {&_swigt__p_LLWearable, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LuaAgent[] = {  {&_swigt__p_LuaAgent, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_LuaWorldMap[] = {  {&_swigt__p_LuaWorldMap, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_child_list_t[] = {  {&_swigt__p_child_list_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_const_child_list_t[] = {  {&_swigt__p_const_child_list_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_eLayoutOrientation[] = {  {&_swigt__p_eLayoutOrientation, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_eObjectPartitions[] = {  {&_swigt__p_eObjectPartitions, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_action_type[] = {  {&_swigt__p_e_action_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_anim_request[] = {  {&_swigt__p_e_anim_request, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_camera_modes[] = {  {&_swigt__p_e_camera_modes, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_camera_position[] = {  {&_swigt__p_e_camera_position, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_grid_mode[] = {  {&_swigt__p_e_grid_mode, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_object_update_type[] = {  {&_swigt__p_e_object_update_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_selection_type[] = {  {&_swigt__p_e_selection_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_e_send_type[] = {  {&_swigt__p_e_send_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_list_t[] = {  {&_swigt__p_list_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_root_iterator[] = {  {&_swigt__p_root_iterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_root_object_iterator[] = {  {&_swigt__p_root_object_iterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_skip_list_t[] = {  {&_swigt__p_skip_list_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_valid_iterator[] = {  {&_swigt__p_valid_iterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_valid_root_iterator[] = {  {&_swigt__p_valid_root_iterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vobj_list_t[] = {  {&_swigt__p_vobj_list_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_wchar_t[] = {  {&_swigt__p_wchar_t, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_EAnimate,
-  _swigc__p_EVOType,
-  _swigc__p_LLSafeHandleT_LLObjectSelection_t,
-  _swigc__p_LLSimInfo,
-  _swigc__p_LLUUID,
-  _swigc__p_LLVOAvatar,
-  _swigc__p_LLViewerRegion,
-  _swigc__p_LLWearable,
-  _swigc__p_LuaAgent,
-  _swigc__p_LuaWorldMap,
-  _swigc__p_child_list_t,
-  _swigc__p_const_child_list_t,
-  _swigc__p_double,
-  _swigc__p_eLayoutOrientation,
-  _swigc__p_eObjectPartitions,
-  _swigc__p_e_action_type,
-  _swigc__p_e_anim_request,
-  _swigc__p_e_camera_modes,
-  _swigc__p_e_camera_position,
-  _swigc__p_e_grid_mode,
-  _swigc__p_e_object_update_type,
-  _swigc__p_e_selection_type,
-  _swigc__p_e_send_type,
-  _swigc__p_float,
-  _swigc__p_int,
-  _swigc__p_iterator,
-  _swigc__p_list_t,
-  _swigc__p_long_long,
-  _swigc__p_root_iterator,
-  _swigc__p_root_object_iterator,
-  _swigc__p_short,
-  _swigc__p_signed_char,
-  _swigc__p_skip_list_t,
-  _swigc__p_std__string,
-  _swigc__p_unsigned_char,
-  _swigc__p_unsigned_int,
-  _swigc__p_unsigned_long_long,
-  _swigc__p_unsigned_short,
-  _swigc__p_valid_iterator,
-  _swigc__p_valid_root_iterator,
-  _swigc__p_vobj_list_t,
-  _swigc__p_wchar_t,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found, init;
-
-  clientdata = clientdata;
-
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &swig_module;
-    init = 1;
-  } else {
-    init = 0;
-  }
-
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &swig_module);
-    module_head = &swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter->next;
-    } while (iter!= module_head);
-
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head->next;
-    module_head->next = &swig_module;
-  }
-
-  /* When multiple interpeters are used, a module could have already been initialized in
-     a different interpreter, but not yet have a pointer in this interpreter.
-     In this case, we do not want to continue adding types... everything should be
-     set up already */
-  if (init == 0) return;
-
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
-#endif
-  for (i = 0; i < swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-  
-#ifdef SWIGRUNTIME_DEBUG
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-#endif
-
-    /* if there is another module already loaded */
-    if (swig_module.next != &swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found type %s\n", type->name);
-#endif
-      if (swig_module.type_initial[i]->clientdata) {
-	type->clientdata = swig_module.type_initial[i]->clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast->type) {
-    
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
-#endif
-      if (swig_module.next != &swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-#ifdef SWIGRUNTIME_DEBUG
-	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
-#endif
-      }
-      if (ret) {
-	if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
-#endif
-	  cast->type = ret;
-	  ret = 0;
-	} else {
-	  /* Check for casting already in the list */
-	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
-#ifdef SWIGRUNTIME_DEBUG
-	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
-#endif
-	  if (!ocast) ret = 0;
-	}
-      }
-
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
-#endif
-        if (type->cast) {
-          type->cast->prev = cast;
-          cast->next = type->cast;
-        }
-        type->cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules->types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-
-#ifdef SWIGRUNTIME_DEBUG
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-  for (i = 0; i < swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-    while (cast->type) {
-      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
-      cast++;
-      ++j;
-    }
-  printf("---- Total casts: %d\n",j);
-  }
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-
-  if (init_run) return;
-  init_run = 1;
-
-  for (i = 0; i < swig_module.size; i++) {
-    if (swig_module.types[i]->clientdata) {
-      equiv = swig_module.types[i]->cast;
-      while (equiv) {
-        if (!equiv->converter) {
-          if (equiv->type && !equiv->type->clientdata)
-            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-        }
-        equiv = equiv->next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{ /* c-mode */
-#endif
-}
-#endif
-
-
-
-/* Forward declaration of where the user's %init{} gets inserted */
-void SWIG_init_user(lua_State* L );
-    
-#ifdef __cplusplus
-extern "C" {
-#endif
-/* this is the initialization function
-  added at the very end of the code
-  the function is always called SWIG_init, but an eariler #define will rename it
-*/
-SWIGEXPORT int SWIG_init(lua_State* L)
-{
-  int i;
-  /* start with global table */
-  lua_pushvalue(L,LUA_GLOBALSINDEX);
-  /* SWIG's internal initalisation */
-  SWIG_InitializeModule((void*)L);
-  SWIG_PropagateClientData();
-  /* add a global fn */
-  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
-  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);
-  /* begin the module (its a table with the same name as the module) */
-  SWIG_Lua_module_begin(L,SWIG_name);
-  /* add commands/functions */
-  for (i = 0; swig_commands[i].name; i++){
-    SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
-  }
-  /* add variables */
-  for (i = 0; swig_variables[i].name; i++){
-    SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
-  }
-  /* set up base class pointers (the hierachy) */
-  for (i = 0; swig_types[i]; i++){
-    if (swig_types[i]->clientdata){
-      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
-    }
-  }
-  /* additional registration structs & classes in lua */
-  for (i = 0; swig_types[i]; i++){
-    if (swig_types[i]->clientdata){
-      SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
-    }
-  }
-  /* constants */
-  SWIG_Lua_InstallConstants(L,swig_constants);
-  /* invoke user-specific initialization */
-  SWIG_init_user(L);
-  /* end module */
-  lua_pop(L,1);  /* tidy stack (remove module table)*/
-  lua_pop(L,1);  /* tidy stack (remove global table)*/
-  return 1;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-
-const char* SWIG_LUACODE=
-  "";
-
-void SWIG_init_user(lua_State* L)
-{
-  /* exec Lua code if applicable */
-  SWIG_Lua_dostring(L,SWIG_LUACODE);
-}
-
+#include "LuaBase_wrap.cxx"
diff -daur indra/newview/LuaBase.swig Update/newview/LuaBase.swig
--- indra/newview/LuaBase.swig	2009-12-26 16:57:40.109457200 -0600
+++ Update/newview/LuaBase.swig	2009-12-28 02:34:56.320291600 -0600
@@ -25,6 +25,7 @@
 %module SL
 %{
 #include "llviewerprecompiledheaders.h"
+
 #include "stdtypes.h"
 //#include "SLua.h"
 #include "llfloater.h"
@@ -42,6 +43,8 @@
 #include "llselectmgr.h"
 %}
 
+%include <std_string.i>
+
 %import "../llcommon/stdtypes.h"
 %import "../llprimitive/llprimitive.h"
 %import "../newview/llagent.h"
@@ -88,5 +91,4 @@
 %include "LuaAgent_f.h"
 
 extern bool gAllowWorldMap;
-extern LLAgent *gAgent;
-
+extern LLAgent *gAgent;
\ No newline at end of file
diff -daur indra/newview/LuaBase_f.cpp Update/newview/LuaBase_f.cpp
--- indra/newview/LuaBase_f.cpp	2009-12-26 16:57:40.922503700 -0600
+++ Update/newview/LuaBase_f.cpp	2009-12-28 22:53:03.240990900 -0600
@@ -1,4 +1,5 @@
 #include "llviewerprecompiledheaders.h"
+
 #include "LuaBase_f.h"
 
 #include <sstream>
@@ -15,6 +16,8 @@
 #include "llviewerstats.h"
 #include "llviewerobjectlist.h"
 #include "llviewerregion.h"
+#include "llurldispatcher.h"
+#include "flexconsole.h"
 
 //#include <direct.h>
 #include <errno.h>
@@ -31,6 +34,7 @@
 	dongs.mSourceType=CHAT_SOURCE_LUA;
 	if(IsDebug) dongs.mChatType=CHAT_TYPE_DEBUG_MSG;
 	LLFloaterChat::addChat(dongs);
+	LLFloaterLuaConsole::addOutput(mesg,false); //no debug exception yet.
 }
 
 void LuaPrint(const char *msg)
@@ -59,6 +63,11 @@
 void LuaTouch(const char* uuid)
 {
 	LLViewerObject* object = gObjectList.findObject(LLUUID(uuid));
+	if(!object)
+	{
+		LuaError("No Object Found");
+		return;
+	}
 	LLMessageSystem *msg = gMessageSystem;
 
 	msg->newMessageFast(_PREHASH_ObjectGrab);
@@ -178,6 +187,7 @@
 	err.mSourceType=CHAT_SOURCE_LUA;
 	err.mChatType=CHAT_TYPE_ERROR;
 	LLFloaterChat::addChat(err);
+	LLFloaterLuaConsole::addOutput(msg,true);
 }
 
 const char* LuaGetCWD()
@@ -199,6 +209,11 @@
 {
 	std::string simname(msg);
 	LLSimInfo *sim=LLWorldMap::getInstance()->simInfoFromName(simname);
+	if(!sim)
+	{
+		LuaError("Sim Not Found");
+		return NULL;
+	}
 	return LLWorld::getInstance()->getRegionFromHandle(sim->mHandle);
 }
 
@@ -209,10 +224,12 @@
 
 void Lua_tp(const char* SimName, int x, int y, int z)
 {
-	std::string simname(SimName);
-	LLVector3 pl(x,y,z);
-	LLSimInfo *si=LLWorldMap::getInstance()->simInfoFromName(simname);
-	gAgent.teleportRequest(si->mHandle,pl);
+	std::string name(SimName);
+	std::transform(name.begin(), name.end(), name.begin(), tolower);
+	if(name == "home")
+		gAgent.teleportViaLandmark(LLUUID::null);
+	else
+		LLURLDispatcher::dispatchFromTextEditor(llformat("secondlife:///app/teleport/%s/%d/%d/%d",SimName,x,y,z));
 }
 
 bool Lua_exists(const char* Filename)
diff -daur indra/newview/skins/default/xui/en-us/floater_lua_console.xml Update/newview/skins/default/xui/en-us/floater_lua_console.xml
--- indra/newview/skins/default/xui/en-us/floater_lua_console.xml	2009-12-26 16:56:56.291951000 -0600
+++ Update/newview/skins/default/xui/en-us/floater_lua_console.xml	2009-12-28 00:36:56.442345700 -0600
@@ -7,6 +7,7 @@
          bottom="-122" embedded_items="false" enabled="false"
          follows="left|top|right|bottom" font="SansSerif" height="80" left="5"
          max_length="2147483647" mouse_opaque="true" name="Lua Output Editor"
+		 track_bottom="true"
          text_color="ChatHistoryTextColor"
          text_readonly_color="ChatHistoryTextColor" width="415" word_wrap="true" />
     <button bottom="-38" follows="left|top" height="20" label="Clear" left="5"
