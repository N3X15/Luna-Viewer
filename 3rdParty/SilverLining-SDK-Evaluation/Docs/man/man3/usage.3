.TH "usage" 3 "3 Sep 2009" "Version 1.818" "SilverLining" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usage \- Using SilverLining 
.SH "A simple example"
.PP
.SS "Initialization"
Complete sample code for both OpenGL and Direct3D is found in the SampleCode/OpenGLExample, SampleCode/DirectX9Example, and SampleCode/DirectX10Example directories of the SDK (The Linux and MacOSX SDKs only include OpenGL). Here's an overview of some of the key bits of code found in each.
.PP
When your application starts up, you'll want to initialize OpenGL or Direct3D, and create and initialize an Atmosphere object. If you want your clouds to be different every time your application is run, be sure to seed the random number generator as well.
.PP
Under DirectX9, it's important that you create your IDirect3DDevice object WITHOUT the D3DCREATE_PUREDEVICE flag. Silverlining needs to call GetTransform and GetRenderState on your device, in order to put things back the way we found them when we're done drawing.
.PP
By default, SilverLining also requires that you pass D3DPRESENTFLAG_LOCKABLE_BACKBUFFER in the D3DPRESENT_PARAMETERS that you pass into CreateDevice. This is because our lighting pass requires us to read some pixels back from the framebuffer, which requires us to lock it. However, if you set 'render-offscreen = yes' in your SilverLining.config file (located under the Resources folder), we'll do our lighting pass to an offscreen render target instead of the back buffer. With render-offscreen enabled, lockable backbuffers are not required on systems that support offscreen render targets. This will enable you to enable multisampling on your device, as multisampling and lockable backbuffers are mutually exclusive under DirectX. Under DirectX 10, 'render-offscreen' will be enabled by default, as it doesn't support lockable backbuffers at all.
.PP
If your Atmosphere initializes successfully, you can go ahead and start configuring it to add your clouds, and specify the time and location you wish to simualte. We'll get into that next. If it does not initialize successfully, it's likely that the user needs to update the graphics driver. SilverLining has fallback cases for most cases where compatibility might be an issue, but some older drivers have issues even with standard functionality.
.PP
.PP
.nf
// If you want different clouds to be generated every time, remember to seed the
// random number generator.
srand(time(NULL));

// Initialize your Direct3D device object, glut, or wgl as appropriate
InitializeGraphicsSubsystem(); 

// Instantiate an Atmosphere object. Substitute your own purchased license name and code here.
atm = new Atmosphere('Your Company Name', 'Your License Code');

atm->ShowFramerate(true);

// Tell SilverLining we're rendering in OpenGL, the Resources directory is 2 directories
// above the working directory, and we're using a right-handed coordinate system.
if (atm->Initialize(Atmosphere::OPENGL, '..\\..\\Resources\\', true, 0) == Atmosphere::E_NOERROR)
{
        // Set up all the clouds
        SetupAtmosphericConditions();

        // Configure where and when we want to be
        SetTimeAndLocation();

        // Start rendering.
        glutMainLoop();
}
.fi
.PP
.PP
Let's flesh out SetupAtmosphericConditions() from above. Once you have an Atmosphere object initialized, you can access its AtmosphericConditions object to do things like add cloud decks, change the time of day, and simulate wind. Let's write a code snippet to add a cirrus deck, a cumulus congestus deck, and make it a windy day. The code is self-explanatory:
.PP
.PP
.nf
static void SetupCirrusClouds()
{
        CloudLayer *cirrusCloudLayer;

        cirrusCloudLayer = CloudLayerFactory::Create(CIRRUS_FIBRATUS);
        cirrusCloudLayer->SetBaseAltitude(8000);
        cirrusCloudLayer->SetThickness(0);
        cirrusCloudLayer->SetBaseLength(100000);
        cirrusCloudLayer->SetBaseWidth(100000);
        cirrusCloudLayer->SetLayerPosition(0, 0);
        cirrusCloudLayer->SeedClouds(*atm);

        atm->GetConditions()->AddCloudLayer(cirrusCloudLayer);
}
.fi
.PP
.PP
The above routine will create a Cirrus cloud (the high, wispy ones) at an altitude of 8,000 meters and 100 km across. It's centered at the camera position. Cirrus clouds have no modeled thickness, so the thickness is just set to 0.
.PP
Anytime you create a new CloudLayer, you must first
.PP
.PD 0
.IP "\(bu" 2
Instantiate it using the CloudLayerFactory class factory. 
.IP "\(bu" 2
Set its size, coverage, and position parameters 
.IP "\(bu" 2
Call CloudLayer::SeedClouds() to populate the layer with clouds 
.IP "\(bu" 2
Add the layer to your atmosphere via AtmosphericConditions::AddCloudLayer()
.PP
Similarly, let's set up a cumulus congestus deck:
.PP
.PP
.nf
// Add a cumulus congestus deck with 40% sky coverage, which stays centered around the camera position.
static void SetupCumulusCongestusClouds()
{
        CloudLayer *cumulusCongestusLayer;

        cumulusCongestusLayer = CloudLayerFactory::Create(CUMULUS_CONGESTUS_INFINITE);
        cumulusCongestusLayer->SetBaseAltitude(1500);
        cumulusCongestusLayer->SetThickness(100);
        cumulusCongestusLayer->SetBaseLength(30000);
        cumulusCongestusLayer->SetBaseWidth(30000);
        cumulusCongestusLayer->SetDensity(0.4);
        cumulusCongestusLayer->SetLayerPosition(0, 0);
        cumulusCongestusLayer->SeedClouds(*atm);
        cumulusCongestusLayer->GenerateShadowMaps(false);

        atm->GetConditions()->AddCloudLayer(cumulusCongestusLayer);
}
.fi
.PP
.PP
Our SetupAtmosphericConditions function will set up the simulated wind, call the above two functions to create the cirrus and cumulus cloud decks, and finally set the simulated visibility - which will affect the fog effects on the clouds themselves:
.PP
.PP
.nf
// Configure SilverLining for the desired wind, clouds, and visibility.
static void SetupAtmosphericConditions()
{
        // Set up wind blowing south at 50 meters/sec
        WindVolume wv;
        wv.SetDirection(180);
        wv.SetMinAltitude(0);
        wv.SetMaxAltitude(10000);
        wv.SetWindSpeed(50);
        atm->GetConditions()->SetWind(wv);

        // Set up the desired cloud types.
        SetupCirrusClouds();
        SetupCumulusCongestusClouds();

        // Set visibility in meters
        atm->GetConditions()->SetVisibility(100000);
}
.fi
.PP
.PP
If you wish to simulate a particular place and time, you should also set that up in your initialization. You can also change this at any time while the application is running. Be sure that the time zone you specify in the LocalTime object is consistent with the longitude you specify in the Location object, or else you'll be very confused by the results!
.PP
.PP
.nf
// Sets the simulated location and local time.
// Note, it's important that your longitude in the Location agrees with 
// the time zone in the LocalTime.
static void SetTimeAndLocation()
{
        Location loc;
        loc.SetLatitude(45);
        loc.SetLongitude(-122); 

        LocalTime tm;
        tm.SetYear(1971);
        tm.SetMonth(8);
        tm.SetDay(5);
        tm.SetHour(14);
        tm.SetMinutes(0);
        tm.SetSeconds(0);
        tm.SetObservingDaylightSavingsTime(true);
        tm.SetTimeZone(PST);

        atm->GetConditions()->SetTime(tm);
        atm->GetConditions()->SetLocation(loc);
}
.fi
.PP
.SS "Infinite Cloud Layers"
There are two special types of cloud layers you may create with the CloudLayerFactory: CUMULUS_CONGESTUS_INFINITE and CUMULUS_MEDIOCRIS_INFINITE.
.PP
These cloud layers will stay centered at the camera location; as the camera moves, clouds that leave the bounding area defined by the cloud layer's length and width will be repositioned to pop in where the camera's moving toward. Similarly, if wind blows clouds outside of the cloud layer, they will wrap around to the other side of the layer.
.PP
This gives you the effect of an 'infinite' cloud layer, where the clouds will never blow away and you can't move the camera away from them. The larger the length and width you create the cloud layer with, the less noticable the popping will be as clouds are repositioned - especially if the clouds are being fogged in the distance by setting AtmosphericConditions::SetVisibility() to a value similar to the cloud layer's dimensions.
.SS "Integrating SilverLining with your Rendering Loop"
That's pretty much it for initialization. Now, how do you integrate SilverLining with the rendering of each frame? It's quite simple. When you render a frame of animation, you'll want to follow these steps:
.PP
.PD 0
.IP "\(bu" 2
Set the modelview and projection matrices to represent your camera position and scene. 
.IP "\(bu" 2
Call Atmosphere::BeginFrame() to draw the sky and compute lighting information. 
.IP "\(bu" 2
Set up your scene's lighting by using the information returned from Atmosphere::GetSunOrMoonPosition(), Atmosphere::GetSunOrMoonColor(), and Atmosphere::GetAmbientColor(). 
.IP "\(bu" 2
Set up your scene's fog by using the information returned from Atmosphere::GetFogEnabled() and Atmosphere::GetFogSettings(). 
.IP "\(bu" 2
Draw your scene's objects. 
.IP "\(bu" 2
Call Atmosphere::EndFrame() to draw the clouds.
.PP
Here's an example of the render loop under OpenGL:
.PP
.PP
.nf
void Display()
{
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45.0, aspectRatio, 2, 100000);

        // Increment the yaw each frame to spin the camera around 
        yaw += 0.05;

        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glRotatef(-10, 1, 0, 0);
        glRotatef(yaw, 0, 1, 0);
        glTranslatef(0, -100, 0);

    // Pass in the view and projection matrices to SilverLining.
    double mv[16], proj[16];
    glGetDoublev(GL_MODELVIEW_MATRIX, mv);
    glGetDoublev(GL_PROJECTION_MATRIX, proj);
    atm->SetCameraMatrix(mv);
    atm->SetProjectionMatrix(proj);

        // After setting up your projection and modelview matrices to reflect the current
        // camera position, call Atmosphere::BeginFrame() to draw the sky and do the lighting
        // pass on the clouds, if necessary.
        atm->BeginFrame(true);

        // Now, do all your own drawing...
        SetSceneLighting();
        SetSceneFog();
        DrawGroundPlane();

        // When you're done, call Atmosphere::EndFrame() to draw all the clouds from back to front.
        atm->EndFrame();

        // Now swap the back and front buffers.
        glutSwapBuffers();

        glutPostRedisplay();
}
.fi
.PP
.PP
And a main rendering loop under DirectX 9... note that this example uses a right-handed coordinate system. The handedness must match what you specified when initializing the Atmosphere object. This example doesn't handle lost devices; you can simply delete and recreate your Atmosphere object when a device is lost in order to release and recreate its resources.
.PP
DirectX10 would be similar, but instead of setting the view and projection matrices into the device's fixed function pipeline as you would in DirectX9, you'll need to pass those to your vertex programs directly. See the DirectX 10 sample code provided with the SDK for a complete example.
.PP
.PP
.nf
static void RenderFrame(HWND hWnd)
{
        static float lastTime = (float)timeGetTime();

        if (atm && device)
        {
                D3DXMATRIX Rot, Yaw, Pitch;
                D3DXMatrixRotationX(&Pitch, -10.0f * (3.14f / 360.0f));
                D3DXMatrixRotationY(&Yaw, yaw);
                D3DXMatrixMultiply(&Rot, &Yaw, &Pitch);
                D3DXMATRIX Pos;
                D3DXMatrixTranslation(&Pos, 0, -100, 0);
                D3DXMATRIX view;
                D3DXMatrixMultiply(&view, &Pos, &Rot);

                device->SetTransform(D3DTS_VIEW, &view);

                //
                // Set projection matrix.
                //
                D3DVIEWPORT9 vp;
                device->GetViewport(&vp);

                D3DXMATRIX proj;
                D3DXMatrixPerspectiveFovRH(
                        &proj,
                        45.0 * (D3DX_PI / 180.0),
                        (float)vp.Width / (float)vp.Height,
                        2.0f,
                        200000.0f);
                device->SetTransform(D3DTS_PROJECTION, &proj);

        // Set view and proj matrices with SilverLining
        if (atm)
        {
            double pView[16], pProj[16];
                int i = 0;
                for (int row = 0; row < 4; row++)
                {
                        for (int col = 0; col < 4; col++)
                        {
                                pView[i] = view(row, col);
                                pProj[i] = proj(row, col);
                    i++;
                        }
                }

            atm->SetCameraMatrix(pView);
            atm->SetProjectionMatrix(pProj);
        }

                device->BeginScene();

                // Call BeginFrame after scene has begun and modelview / projection matrices 
                // properly set for the camera position. This will draw the sky if you pass true.
                atm->BeginFrame(true);

                // Now, do all your own drawing...
                SetSceneLighting();
                SetSceneFog();
                DrawGroundPlane();

                // Call EndFrame to draw all the clouds from back to front.
                atm->EndFrame();

                device->EndScene();

                device->Present(0, 0, 0, 0);

                // Trigger another redraw.
                InvalidateRect(hWnd, NULL, FALSE);

                lastTime = currTime;
        }
}
.fi
.PP
.SS "Lighting Your Scene with SilverLining"
In order to light the objects in your scene consistently with the appearance of the sky, SilverLining allows you to query for its modeled directional and ambient light information. It's easy to use this information to light your scene. Here's an example of setting up lighting under OpenGL using SilverLining as guidance:
.PP
.PP
.nf
void SetSceneLighting()
{
        float x, y, z, r, g, b, ra, ga, ba;
        atm->GetSunOrMoonPosition(&x, &y, &z);
        atm->GetSunOrMoonColor(&r, &g, &b);
        atm->GetAmbientColor(&ra, &ga, &ba);

        GLfloat light_ambient[] = {ra, ga, ba, 1.0};
        GLfloat light_diffuse[] = {r, g, b, 1.0};
        GLfloat light_specular[] = {0.0, 0.0, 0.0, 1.0};
        GLfloat light_position[] = {x, y, z, 0};

        glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
        glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
        glLightfv(GL_LIGHT0, GL_POSITION, light_position);
        glEnable(GL_LIGHT0);

        GLfloat mat_amb_diff[] = {1.0, 1.0, 1.0, 1.0};
        GLfloat no_mat[] = {0, 0, 0, 0};
        glMaterialfv(GL_FRONT, GL_AMBIENT, mat_amb_diff);
        glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_amb_diff);
        glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
        glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
}
.fi
.PP
.PP
And the same function for setting the scene's lighting, under DirectX9:
.PP
.PP
.nf
static void SetSceneLighting()
{
        D3DXCOLOR light_ambient, light_diffuse, light_specular;
        D3DXVECTOR3 light_position;

        atm->GetSunOrMoonPosition(&light_position.x, &light_position.y, &light_position.z);
        atm->GetSunOrMoonColor(&light_diffuse.r, &light_diffuse.g, &light_diffuse.b);
        atm->GetAmbientColor(&light_ambient.r, &light_ambient.g, &light_ambient.b);

        light_diffuse.a = light_ambient.a = 1.0;

        D3DLIGHT9 light;
        ::ZeroMemory(&light, sizeof(light));

        light.Type = D3DLIGHT_DIRECTIONAL;
        light.Ambient = light_ambient;
        light.Diffuse = light_diffuse;
        light.Specular = D3DXCOLOR(1, 1, 1, 1);
        light.Direction = D3DXVECTOR3(-light_position.x, -light_position.y, -light_position.z);

        if (device)
        {
                device->SetLight(0, &light);
                device->LightEnable(0, true);
                device->SetRenderState(D3DRS_NORMALIZENORMALS, true);
                device->SetRenderState(D3DRS_SPECULARENABLE, false);
        }
}
.fi
.PP
.PP
DirectX 10 would be similar, but you'd pass the lighting values and position into your shaders instead of to the device.
.SS "Fog Effects with SilverLining"
Finally, SilverLining will also give you guidance on how to configure fog for your scene. If you're inside a stratus cloud deck or inside precipitation, SilverLining will request that you set the fog in your scene appropriately to simulate being inside a thick cloud or inside rain or snow. If Atmosphere::GetFogEnabled() returns true, then SilverLining is asking that you query Atmosphere::GetFogSettings() to obtain information about the fog volume you're currently inside.
.PP
Even if you're not inside or under a cloud, SilverLining can help you set your fog to blend your distant terrain into the sky. SilverLining constantly computes the average color of the sky at the horizon within the current field of view, and makes this accessible via Atmosphere::GetHorizonColor(). Setting the fog color to this, and setting the density consistently with the visibility you passed earlier to Atmosphere::SetVisibility(), will yield realistic results.
.PP
It is possible to simulate a layer of colored haze hugging the ground. This can be useful if Atmosphere::GetHorizonColor() does not produce desirable results for your application. Effectively, this allows you to blend the skybox to a specified color as it approaches the horizon. If you fog your terrain with this same color, you can obscure the horizon line quite nicely for applications that do not render terrain all the way out to the horizon.
.PP
The haze layer is set via Atmosphere::SetHaze(). You may simulate any depth of haze, any color, and any density. Set the depth to 0 to disable haze. It's important to realize that no lighting is performed on the haze; if you want the sky to blend toward a darker color at night, you must pre-multiply the haze color by the light in the scene.
.PP
Here's an example of setting fog under OpenGL, using the GetHorizonColor() method instead of a haze layer of a specified color:
.PP
.PP
.nf
void SetSceneFog()
{
        glEnable(GL_FOG);
        glFogi(GL_FOG_MODE, GL_EXP);

        float hazeDensity = 1.0 / kVisibility;
        bool silverLiningHandledTheFog = false;

        if (atm->GetFogEnabled())
        {
                float density, r, g, b;
                // Note, the fog color returned is already lit
                atm->GetFogSettings(&density, &r, &g, &b);

                if (density > hazeDensity)
                {
                        glFogf(GL_FOG_DENSITY, density);

                        GLfloat fogColor[4] = {r, g, b, 1.0};
                        glFogfv(GL_FOG_COLOR, fogColor);

                        silverLiningHandledTheFog = true;
                }
        }
        
        if (!silverLiningHandledTheFog)
        {
                GLfloat fogColor[4];
                atm->GetHorizonColor(yaw, &fogColor[0], &fogColor[1], &fogColor[2]);
                glFogfv(GL_FOG_COLOR, fogColor);

                glFogf(GL_FOG_DENSITY, hazeDensity);
        }
}
.fi
.PP
.PP
And here's the equivalent DirectX9 code for setting fog:
.PP
.PP
.nf
static void SetSceneFog()
{
        DWORD fogColor;
        float density, r, g, b;

        // If you're inside a cloud, SilverLining will request that you set the fog accordingly.
        if (atm->GetFogEnabled())
        {
                atm->GetFogSettings(&density, &r, &g, &b); // This fog color is pre-lit
        }
        else // Otherwise, setting the fog to the average color of the sky at the horizon works well.
        {
                atm->GetHorizonColor(yaw, &r, &g, &b);
                density = 1.0f / kVisibility;
        }

        BYTE cr, cg, cb, ca;
        cr = (BYTE)(r * 255.0);
        cg = (BYTE)(g * 255.0);
        cb = (BYTE)(b * 255.0);
        ca = 255;

        fogColor = D3DCOLOR_RGBA(cr, cg, cb, ca);

        // Enable fog blending.
        device->SetRenderState(D3DRS_FOGENABLE, TRUE);

        // Set the fog color.
        device->SetRenderState(D3DRS_FOGCOLOR, fogColor);

        // Set fog parameters.
        device->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_EXP);
        device->SetRenderState(D3DRS_FOGDENSITY, *(DWORD *)(&density));
}
.fi
.PP
.PP
Again, DirectX10 is similar, but you would need to pass in the fog parameters to your shaders instead of to the device.
.PP
That's all there is to it! Using the techniques above, you'll be able to integrate SilverLining's sky and cloud rendering into your 3D application, and light and fog the objects in your scene consistently with the sky and clouds rendered by SilverLining.
.PP
If your application specifies its own fog - for example, you're simulating being inside a fog bank - you can tell SilverLining to fog its clouds to a specified color and density. See the AtmosphericConditions::SetFog() method for more information. When you're in thick fog, you'll usually want to just clear your back buffer to the fog color and not call SilverLining at all. The sky won't be visible in such conditions anyhow. Remember to call ClearFog() when you leave the simulated fog bank, as calling SetFog() will override all other atmospheric perspective effects in SilverLining.
.SH "Integration Tips with Popular Scene Graphs"
.PP
.SS "Integrating with OpenSceneGraph"
Silverlining should integrate easily into any rendering engine built on top of OpenGL or DirectX, but we get the most questions about integrating with OpenSceneGraph. We've included some sample code for OpenSceneGraph 2.4 and up with the SDK to get you started; it's a modified osgviewer application that integrates the sky, clouds, and lighting.
.PP
Studying or extending this sample code is the easiest way to get started, but if you want to start from scratch, here are the things you need to know about OpenSceneGraph integration:
.PP
.PD 0
.IP "\(bu" 2
The easiest way to ensure Atmosphere::BeginFrame and Atmosphere::EndFrame are called at the right time is to wrap these calls in osg::Drawable objects. Then, create an osg::Geode for each and add the Drawables to them, and set the Geodes into a renderbin that's used with the rest of your scene. Just set the object that calls BeginFrame to have an early position in the renderbin (like -1) and the EndFrame drawable to a very high position. 
.IP "\(bu" 2
If you're going to use multithreaded mode, you need to take care that Atmosphere::Initialize is called in the rendering thread. An easy way to do this is keeping a static boolean in the drawable that calls BeginFrame, and call the initialization right before BeginFrame is called for the first time. That's also the right time to set up your cloud layers. 
.IP "\(bu" 2
You'll probably want to disable how OpenSceneGraph automatically computes the near and far clip planes and set these explicitly, since OSG won't know about the bounds of SilverLining's sky box and its clouds. Alternately, you can use the implementation of ClampProjectionMatrixCallback included with the sample code to try and include the bounds of the sky's objects and modify the size of the sky box as necessary. We recommend simply disabling the automatic computation of the clip planes unless you need to do viewpoints from space where it's necessary to push out the near clip plane in order to preserve depth buffer resolution. 
.IP "\(bu" 2
Remember when SilverLining draws the sky, it will clear the color buffer and the depth buffer in the process. You can get a little performance back by disabling buffer clearing in OpenSceneGraph, as it's redundant.
.PP
Note that our sample code doesn't handle the case of multiple contexts. If you're running OSG with multiple monitors, you'll probably want to develop in single-monitor mode to get started. If you do have multiple windows in your OSG application, you can instantiate an Atmosphere object for each window and attach them to each window's camera, as illustrated in the sample code. Be sure to read the section on multiple context support below; you'll need to take care that your Atmosphere and CloudLayer objects are initialized at just the right time. In particular, adding new cloud layers after initialization should be done within the SkyDrawable::drawImplementation method AFTER the call to Atmosphere::BeginFrame() in a multi-context application.
.SS "Integrating with Ogre3D"
The sample code directory of the SDK includes source code that illustrates Ogre3D integration. In the style of the Ogre3D demo applications, most of the implementation is in the header file (SilverLiningDemo.h).
.PP
Be sure to read the important notes in the comments at the top of this file. Since both Ogre3D and SilverLining use NVidia's Cg libraries, it's important that you aren't dynamically linking on older versions of the Cg DLL's that are included with Ogre3D. Copy the latest Cg DLL's into the working directory for your application, and you should be good to go. The May 2008 build of Cg is included in our SDK's third-party directory, but what's important is that you make sure that the Cg DLL's your application links in dynamically are the same or newer than the ones SilverLining was linked against.
.PP
Otherwise, integration with Ogre3D is fairly straightforward. The trick is to implement a RenderQueueListener in order to get the hooks you need for the beginning and end of frame. The sample code also illustrates how to obtain the pointer to the Direct3D device from Ogre3D, which you'll need if you're using Direct3D instead of OpenGL. Another Direct3D-specific gotcha: you need to tell SilverLining to render its lighting pass offscreen, since Ogre3D's backbuffer is not readable. The sample code shows you how to call Atmosphere::SetConfigOption() to achieve this.
.SH "Using SilverLining in Geocentric or ECEF (Earth Centered Earth Fixed) Coordinates"
.PP
SilverLining has successfully been integrated into 'whole-Earth' applications, using coordinate systems where the origin is at the center of the Earth, with major axes pointing through the North Pole and through latitude, longitude (0,0). Wrapping your head around how to configure SilverLining's basis vectors and how to position cloud layers in this sort of environment isn't easy, so here are some tips.
.PP
What you want to do is set the up and right vectors each frame such that 'up' is the normalized vector from the origin (center of the earth) to your location, and 'right' points East from your location. When positioning a cloud layer, set its base altitude to your desired altitude of the bottom of the cloud layer plus the radius of the Earth at your location.
.PP
The way SetLayerPosition() works on a cloud layer is that it sets the position of the layer as (eastCoord, baseAltitude, southCoord), then transforms that position by the basis defined by the up and right vectors you set. So, think of it as defining the position of the cloud layer relative to the North Pole in geocentric coords, and then it gets rotated over the position defined by the up vector, which points from the center of the Earth to where you are.
.PP
An even simpler way to approach it is to set the up and right vectors for whatever location you want the clouds over, set the cloud layer's base altitude to the desired altitude + the Earth's radius, and then set the 'east' and 'south' offsets to zero.
.PP
If you intend to render the Earth from space, be sure to also look at the geocentric parameter of Atmosphere::BeginFrame(). At very high altitudes, drawing the sun, moon, and stars using horizon coordinates will break down; this parameter will cause everything to be rendered in geocentric space instead. Also check out the enable-atmosphere-from-space setting in resources/SilverLining.config. With this on, SilverLining will render a ring around the Earth representing the atmosphere as you leave it - it assumes that a unit in your coordinate system represents one meter, and you're rendering the Earth itself with a realistic size.
.SH "Simulating Precipitation with SilverLining"
.PP
SilverLining includes particle systems that will simulate any amount of rain, sleet, or snowfall that's likely to occur in nature. It will also pass back fog settings that will let you accurately simulate the reduction in visiblity due to the precipitation. SilverLining takes the precipitation rate you specify, and calculates the distribution of particle sizes, particle velocities, and visiblity using research from the meteorology community based on real-world observations.
.PP
Precipitation may be attached to cloud layers, so as you pass underneath a cloud, the precipitation will automatically start and stop.
.PP
Although it's sophisticated, it's easy to use. All you need to do is call CloudLayer::SetPrecipitation() on a stratus or cumulus CloudLayer object. You can do this when you're initializing your CloudLayers, or change it any any time thereafter.
.PP
CloudLayer::SetPrecipitation only takes two values - the precipitation type (CloudLayer::RAIN , CloudLayer::SLEET, or CloudLayer::SNOW), and the precipitation rate. The rate is specified in millimeters per hour - in the case of snow, this is the liquid equivalent precipitation rate, and not the accumulation rate. Reasonable values for the rate would range from 1.0 to 30.0.
.PP
You may simulate mixed precipitation by calling CloudLayer::SetPrecipitation consecutively with different precipitation types. For example, to simulate a 50/50 blend of sleet and snow at an overall rate of 20 mm/hr, you could call SetPrecipitation(CloudLayer::SLEET, 10.0); SetPrecipitation(CloudLayer::WET_SNOW, 10.0);
.PP
If you want to turn precipitation off on a CloudLayer, just call CloudLayer::SetPrecipitation() with a precipitation type of CloudLayer::NONE. Doing this will remove all precipitation effects you set previously on this CloudLayer.
.PP
If you want precipitation effects to be applied globally, independently of CloudLayers, you may instead use the AtmosphericConditions::SetPrecipitation() method. This allows you to use SilverLining's precipitation effects without using SilverLining's clouds, if you so desire.
.PP
To take advantage of the visibility reduction effects, be sure to implement the code described in 'Fog Effects with SilverLining' below.
.SH "Manipulating Time with SilverLining"
.PP
By default, SilverLining will simulate the time you specify with AtmosphericConditions::SetTime(). Clouds will move with the wind over time, but the sun, moon, stars, and appearance of the sky won't change until you call SetTime() again. This is adequate for most applications, and it ensures good performance.
.PP
Some applications need to control the passage of time. You might need to go backwards in time in order to replay a scene. Or you might want to accelerate time for a time-lapse photography sort of effect. Or, you may simply want to filter the time between frames to ensure smooth animation. SilverLining allows you to replace its own internal millisecond timer with your own, to accomplish such effects.
.PP
To do so, implement a MillisecondTimer class of your own, and pass it to AtmosphericConditions::SetMillisecondTimer(). Here's an example of a MillisecondTimer that speeds up the passage of time 10X:
.PP
.PP
.nf
class MyMillisecondTimer : public MillisecondTimer
{
public:
        virtual unsigned long GetMilliseconds() const
        {
                return timeGetTime() * 10;
        }
};
.fi
.PP
.PP
To use this timer, pass it into your AtmosphericConditions class, like this:
.PP
.PP
.nf
        MyMillisecondTimer *timer = new MyMillisecondTimer();
        atm->GetConditions()->SetMillisecondTimer(timer);
.fi
.PP
.PP
You are responsible for deleting your timer class at shutdown. To restore the default timer, call SetMillisecondTimer(NULL).
.PP
Your new timer will influence the rate at which clouds move, but by default, that's all that millisecond timers influence. You may also set the sun, moon, stars, and appearance of the sky to change dynamically over time. To do so, call AtmosphericConditions::EnableTimePassage(). For example:
.PP
.PP
.nf
        atm->GetConditions()->EnableTimePassage(true, 20000);
.fi
.PP
.PP
The first parameter enables dynamic passage of the simulated time. The second specifies the minimum time interval, in milliseconds (as defined by your own MillisecondTimer if you're using one) between cloud deck relighting passes. Relighting a cloud deck is a relatively expensive operation, and you may not want to relight during an interactive scene. You'll at least want to do so infrequently, as the above example does. If you want the sun, moon, stars, and sky to change smoothly over time but don't want to incur the costs of cloud relighting at all, pass -1 for the second parameter.
.PP
For truly smooth time lapse effects with continuous relighting of the clouds every frame, a 'quick and dirty' lighting mode is available. It is a simpler lighting model than the default one; it simply makes cloud puffs darker the deeper they are inside the cloud's bounding ellipsoid from the light source. It won't generate a shadow map for the cloud layer, and it won't result in clouds shadowing each other. But if you don't need shadows from the clouds, it looks almost as good and it's fast enough for relighting every frame. To enable this mode, edit the SilverLining.config file under the resources folder with any text editor. Search for the setting 'cumulus-lighting-quick-and-dirty' and set it to 'yes'. You may also want to experiment with the cumulus-lighting-quick-and-dirty-attenuation setting, which will affect the brightness and contrast of the clouds in your scene. With 'quick and dirty' lighting enabled, you can set the second parameter to EnableTimePassage to zero and still maintain real-time performance. Resulting scenes of the sun setting behind a deck of cumulus congestus clouds can be stunning.
.PP
One thing to watch out for when accelerating time - if you have cumulonimbus clouds in your scene, this might result in lightning being rendered much more frequently, which can both look strange and affect performance. To counteract this, increase the config setting lightning-max-discharge-period accordingly. Alternately, lightning may be disabled altogether by setting cumulonimbus-lightning-density to 0.
.SH "Considerations for Multi-Channel and Multi-Context Setups"
.PP
Many training simulator applications require a consistent scene drawn across several systems, or 'channels', together. SilverLining provides two approaches to ensuring the clouds are consistent across multiple computers.
.PP
The simplest solution is to seed the standard library's random number generator consistently on each channel, using srand(). Cloud layers generated in the same order with the same parameters will then be consistent.
.PP
Alternately, you may use the CloudLayer::Save() method to pre-generate cloud layers for your scene, and save them to disk. Then, you can distribute these saved cloud layers to each channel, and load them at runtime using CloudLayer::Restore(). This approach also has the benefit of speeding up your application's initialization a bit.
.PP
Some applications also require drawing multiple scenes on a single channel, across multiple windows or graphics contexts. Using SilverLining across multiple contexts in the same application is supported, but requires some care.
.PP
Each graphics context must have its own \fBSilverLining::Atmosphere\fP object associated with it. This means that for each context, you must instantiate and initialize a seperate Atmosphere object, and use the correct Atmosphere for the context you are currently rendering to. The Atmosphere must be initialized while its associated graphics context is currently active, and any cloud layers added to the scene must also be added to each Atmosphere while the associated context is active.
.PP
Internally, SilverLining maintains a concept of a 'current atmosphere' that is updated whenever Atmosphere::Initialize() or Atmosphere::BeginFrame() is called. Any operations to the Atmosphere, such as adding or removing cloud layers, must happen following one of these calls.
.PP
So, to recap: if you're rendering across multiple windows, make sure you associate an Atmosphere object for each window. You should only add or remove cloud layers following a call to Atmosphere::Initialize() or Atmosphere::EndFrame() in this situation, and the Atmosphere and cloud layers must be initialized and drawn while the correct window or graphics context is currently active. Generally, the easiest way to accomplish this is by initializing and modifying the Atmosphere object within your application's drawing method.
.SH "Managing Your Own Drawing"
.PP
For many applications, allowing SilverLining to draw its own clouds is a simple approach that will get you up and running quickly with good results. Other applications may prefer to manage their own cloud drawing, in order to ensure that clouds are sorted properly with respect to other translucent objects in the scene. SilverLining provides you with access to the underlying translucent objects it normally renders in Atmosphere::EndFrame() for this purpose.
.PP
If you call Atmosphere::EndFrame(false), this tells SilverLining that it should build up a list of translucent objects to draw within the EndFrame call, but not to actually draw them. After calling EndFrame(false), you may then obtain a list of translucent objects with the Atmosphere::GetObjects() call.
.PP
Translucent objects are generally rendered last in a scene, in back-to-front order with respect to the current viewpoint. Use the Atmosphere::GetObjectDistance() method to obtain the distance from a given viewpoint to each object for sorting purposes. Once your translucent objects are sorted and you're ready to draw them, you may draw a SilverLining ObjectHandle using the Atmosphere::DrawObject() method. Note, you must have blending enabled prior to calling DrawObject().
.PP
Here's an example of manually drawing clouds following a call to Atmosphere::EndFrame(false):
.PP
.PP
.nf
        
static bool comp(ObjectHandle c1, ObjectHandle c2)
{
        double d1 = atm->GetObjectDistance(c1, c2, camX, camY, camZ);
        double d2 = atm->GetObjectDistance(c2, c1, camX, camY, camZ);

        return (d1 > d2);
}

void DrawClouds()
{
        std::vector<ObjectHandle>& objs = atm->GetObjects();

        sort(objs.begin(), objs.end(), comp);

        glEnable(GL_BLEND);
        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_DEPTH_TEST);
        glDepthMask(0);
        glEnable(GL_TEXTURE_2D);
        glDisable(GL_LIGHTING);
        glDisable(GL_FOG);

        std::vector<ObjectHandle>::iterator it;
        for (it = objs.begin(); it != objs.end(); it++)
        {
                atm->DrawObject(*it);
        }

        glDepthMask(1);
}
.fi
.PP
.PP
If you instead call EndFrame(true), this code isn't necessary, and EndFrame() will draw the cloud objects on its own.
.SH "Advanced: using shadow maps"
.PP
A by-product of how SilverLining lights its clouds is an image that may be used as a shadow map for your scene. Using this, clouds from SilverLining may cast shadows on the objects in your world.
.PP
You may instruct a CloudLayer object to preserve its shadow map for your use by calling CloudLayer::GenerateShadowMaps(). This method will only work if the cloud layer supports shadow maps (cirrus and stratus decks do not.) You may find out if a cloud layer can generate shadow maps by calling CloudLayer::SupportsShadowMaps(). For example:
.PP
.PP
.nf
CloudLayer *shadowMapLayer;

...

if (shadowMapLayer->SupportsShadowMaps())
{
        shadowMapLayer->GenerateShadowMaps(true);
}
.fi
.PP
.PP
Shadow maps are not generated under DirectX 10, or under DirectX 9 if 'render-offscreen' is enabled.
.PP
Once you have a CloudLayer configured to generate shadow maps, you may use the CloudLayer::BindShadowMap method to bind the shadow map to a given texture stage, and to retrieve the projection * view matrix of the light source that generated the shadow map. Using this information, you can enable texture coordinate generation or use your own shader to apply the shadow map to the objects in your scene. Here's an example in OpenGL on how to configure the pipeline to do shadow mapping using SilverLining's shadow maps:
.PP
.PP
.nf
double m[16];
if (shadowMapLayer->BindShadowMap(1, m))
{
        Matrix4 bias
        (0.5f, 0.0f, 0.0f, 0.5f,
        0.0f, 0.5f, 0.0f, 0.5f,
        0.0f, 0.0f, 0.5f, 0.5f,
        0.0f, 0.0f, 0.0f, 1.0f);

        Matrix4 lightProjView(m);

        Matrix4 textureMatrix = bias * lightProjView;

        //Set up texture coordinate generation.
        glActiveTexture(kGeospecificOnly ? GL_TEXTURE1 : GL_TEXTURE2);
        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
        glTexGendv(GL_S, GL_EYE_PLANE, textureMatrix.GetRow(0));
        glEnable(GL_TEXTURE_GEN_S);

        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
        glTexGendv(GL_T, GL_EYE_PLANE, textureMatrix.GetRow(1));
        glEnable(GL_TEXTURE_GEN_T);

        glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
        glTexGendv(GL_R, GL_EYE_PLANE, textureMatrix.GetRow(2));
        glEnable(GL_TEXTURE_GEN_R);

        glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
        glTexGendv(GL_Q, GL_EYE_PLANE, textureMatrix.GetRow(3));
        glEnable(GL_TEXTURE_GEN_Q);

        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
        glEnable(GL_TEXTURE_2D);
}
.fi
.PP
.PP
Once the vertex pipeline has been configured to generate the correct texture coordinates for the shadow map's texture stage as above, you also need to shade your fragments correctly to blend the shadow map with your primary texture. Here's an example on a way to configure this in OpenGL:
.PP
.PP
.nf
// Stage 1 = prev * shadow
glActiveTexture(GL_TEXTURE1);
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE);
glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_PREVIOUS);
glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);
glEnable(GL_TEXTURE_2D);

// Stage 0 = tex * primary color
glActiveTexture(GL_TEXTURE0);
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);
glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR);
glEnable(GL_TEXTURE_2D);
.fi
.PP
.PP
This technique is used to create the cloud shadow effects in the SilverLining Demo application, available at our website at http://www.sundog-soft.com/.
.SH "Using SilverLining with High Dynamic Range applications (HDR)"
.PP
Licensed users with access to the full source may recompile SilverLining such that it uses floating point RGBA values with 32 bits per channel, instead of the default 8 bits per channel. This mode will consume more memory, but enables HDR effects by allowing our sky shader to render beyond the bounds of [0,1].
.PP
To do this, uncomment the preprocessor definition of FLOATING_POINT_COLOR in VertexBuffer.h, and recompile the SilverLining library (and also the rendering DLL's for Windows users, which are seperate project files.) This will cause SilverLining to use 128 bit color, and use an alternate Sky shader that does not clamp the final vertex colors to [0,1]. If you need to adjust this shader to interact better with your own HDR scheme, the HDR sky shader is in the Resources folder under Shaders/SkyHDR.cg. 
