.TH "SilverLining::Atmosphere" 3 "3 Sep 2009" "Version 1.818" "SilverLining" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SilverLining::Atmosphere \- This class is the main interface to SilverLining.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <Atmosphere.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAtmosphere\fP (const char *userName, const char *licenseKey)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fB~Atmosphere\fP ()"
.br
.RI "\fIDestructor. \fP"
.ti -1c
.RI "float \fBGetVersionNumber\fP () const "
.br
.RI "\fIReturns the version number of SilverLining (ie, 1.0). \fP"
.ti -1c
.RI "void \fBSetConditions\fP (const \fBAtmosphericConditions\fP &conditions)"
.br
.RI "\fIConfigures the simulated cloud, wind, time, and location. \fP"
.ti -1c
.RI "const \fBAtmosphericConditions\fP & \fBGetConditions\fP () const "
.br
.RI "\fIAccessor to the current cloud, wind, time, and location settings. \fP"
.ti -1c
.RI "void \fBGetSunOrMoonPosition\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the normalized direction of the dominant directional light source. \fP"
.ti -1c
.RI "void \fBGetSunOrMoonPositionGeographic\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the normalized direction of the dominant directional light source. \fP"
.ti -1c
.RI "void \fBGetSunOrMoonPositionEquatorial\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the normalized direction of the dominant directional light source. \fP"
.ti -1c
.RI "void \fBGetSunPosition\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the normalized direction of the sun's light source. \fP"
.ti -1c
.RI "void \fBGetMoonPosition\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the normalized direction of the moon's light source. \fP"
.ti -1c
.RI "void \fBGetSunPositionGeographic\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the direction of the sun, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. \fP"
.ti -1c
.RI "void \fBGetMoonPositionGeographic\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the direction of the moon, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. \fP"
.ti -1c
.RI "void \fBGetSunPositionEquatorial\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the direction of the sun in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. \fP"
.ti -1c
.RI "void \fBGetMoonPositionEquatorial\fP (float *x, float *y, float *z) const "
.br
.RI "\fIRetrieve the direction of the moon in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. \fP"
.ti -1c
.RI "void \fBGetSunOrMoonColor\fP (float *r, float *g, float *b) const "
.br
.RI "\fIReturns the color of the dominant directional light source. \fP"
.ti -1c
.RI "void \fBGetSunColor\fP (float *r, float *g, float *b) const "
.br
.RI "\fIReturns the color of the sun's light source. \fP"
.ti -1c
.RI "void \fBGetMoonColor\fP (float *r, float *g, float *b) const "
.br
.RI "\fIReturns the color of the moon's light source. \fP"
.ti -1c
.RI "void \fBGetAmbientColor\fP (float *r, float *g, float *b) const "
.br
.RI "\fIReturns the color of the ambient 'skylight'. \fP"
.ti -1c
.RI "void \fBGetHorizonColor\fP (float yawDegrees, float *r, float *g, float *b) const "
.br
.RI "\fIReturns the average color of the sky at the horizon. \fP"
.ti -1c
.RI "void \fBGetHorizonColor\fP (float *r, float *g, float *b) const "
.br
.RI "\fIReturns the average color of the sky at the horizon. \fP"
.ti -1c
.RI "bool \fBGetFogEnabled\fP () const "
.br
.RI "\fIReturns whether SilverLining would like to suggest fog settings. \fP"
.ti -1c
.RI "void \fBGetFogSettings\fP (float *density, float *r, float *g, float *b) const "
.br
.RI "\fIReturns exponential fog settings appropriate for your scene. \fP"
.ti -1c
.RI "void \fBSetHaze\fP (float hazeR, float hazeG, float hazeB, double hazeDepth, double hazeDensity)"
.br
.RI "\fICauses the sky to blend toward a specified 'haze color' toward the horizon. \fP"
.ti -1c
.RI "void \fBGetHaze\fP (float &hazeR, float &hazeG, float &hazeB, double &hazeDepth, double &hazeDensity)"
.br
.RI "\fIRetrieves the haze parameters set previously by \fBSetHaze()\fP. \fP"
.ti -1c
.RI "void \fBSetGamma\fP (double gamma)"
.br
.RI "\fISets the value used for gamma correction of the display. \fP"
.ti -1c
.RI "double \fBGetGamma\fP () const "
.br
.RI "\fIRetrieves the value being used for display gamma correction. \fP"
.ti -1c
.RI "void \fBForceLightingRecompute\fP ()"
.br
.RI "\fIForce SilverLining to recompute all cloud lighting. \fP"
.ti -1c
.RI "\fBAtmosphericConditions\fP * \fBGetConditions\fP ()"
.br
.RI "\fIReturn a reference to the current simulated conditions. \fP"
.ti -1c
.RI "int \fBInitialize\fP (int renderer, const char *resourceDirectoryPath, bool rightHanded, void *environment)"
.br
.RI "\fICall this immediately after constructing your scene's \fBAtmosphere\fP and initializing your graphics subsystem (OpenGL, DirectX9, or DirectX10). \fP"
.ti -1c
.RI "void \fBSetUpVector\fP (double x, double y, double z)"
.br
.RI "\fISets the assumption of what direction is 'up'. \fP"
.ti -1c
.RI "void \fBGetUpVector\fP (double &x, double &y, double &z)"
.br
.RI "\fIReturns the direction that SilverLining assumes is 'up' as a unit vector. \fP"
.ti -1c
.RI "void \fBSetRightVector\fP (double x, double y, double z)"
.br
.RI "\fISets the assumption of what direction is 'right'. \fP"
.ti -1c
.RI "void \fBGetRightVector\fP (double &x, double &y, double &z)"
.br
.RI "\fIReturns the direction that SilverLining assumes is 'right' as a unit vector. \fP"
.ti -1c
.RI "void \fBSetCameraMatrix\fP (double *cameraMatrix)"
.br
.RI "\fICall this at the beginning of each rendering loop, prior to calling \fBBeginFrame()\fP. \fP"
.ti -1c
.RI "void \fBSetProjectionMatrix\fP (double *projectionMatrix)"
.br
.RI "\fICall this at the beginning of each rendering loop, prior to calling \fBBeginFrame()\fP. \fP"
.ti -1c
.RI "bool \fBBeginFrame\fP (bool drawSky, bool geocentricMode=false, double skyBoxDimension=0)"
.br
.RI "\fICall this at the beginning of your rendering loop. \fP"
.ti -1c
.RI "bool \fBEndFrame\fP (bool drawClouds=true)"
.br
.RI "\fICall this at the end of your rendering loop. \fP"
.ti -1c
.RI "void \fBShowFramerate\fP (bool framerateOn)"
.br
.RI "\fIDisplay the framerate in the bottom right of the viewport. \fP"
.ti -1c
.RI "double \fBGetFramerate\fP () const "
.br
.RI "\fIReturn the current framerate, based on the rendering time of the previous frame, in frames per second. \fP"
.ti -1c
.RI "std::vector< ObjectHandle > & \fBGetObjects\fP () const "
.br
.RI "\fIIf you called \fBEndFrame()\fP with the drawClouds parameter set to false, no clouds will actually be drawn. \fP"
.ti -1c
.RI "float \fBGetObjectDistance\fP (ObjectHandle obj, float obj2X, float obj2Y, float obj2Z, float sortPosX, float sortPosY, float sortPosZ)"
.br
.RI "\fIIf you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. \fP"
.ti -1c
.RI "float \fBGetObjectDistance\fP (ObjectHandle obj, ObjectHandle obj2, float sortPosX, float sortPosY, float sortPosZ)"
.br
.RI "\fIIf you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. \fP"
.ti -1c
.RI "void \fBGetObjectPosition\fP (ObjectHandle obj, float &x, float &y, float &z)"
.br
.RI "\fIObtains the position, in world coordinates, of a given ObjectHandle obtained from the list returned from \fBGetObjects()\fP. \fP"
.ti -1c
.RI "void \fBDrawObject\fP (ObjectHandle obj)"
.br
.RI "\fIIf you are managing your own cloud object drawing by calling EndFrame(false), then your sorted list of objects may drawn by calling \fBDrawObject()\fP on each object. \fP"
.ti -1c
.RI "void \fBReloadConfigFile\fP ()"
.br
.RI "\fIReloads the SilverLining.config file in the resources directory. \fP"
.ti -1c
.RI "void \fBSetConfigOption\fP (const char *key, const char *value)"
.br
.RI "\fISets a specific SilverLining.config value. \fP"
.ti -1c
.RI "const char * \fBGetConfigOptionString\fP (const char *key) const "
.br
.RI "\fIRetrieves a specific SilverLining.config value as a string. \fP"
.ti -1c
.RI "double \fBGetConfigOptionDouble\fP (const char *key) const "
.br
.RI "\fIRetrieves a specific SilverLining.config value as a double. \fP"
.ti -1c
.RI "bool \fBGetConfigOptionBoolean\fP (const char *key) const "
.br
.RI "\fIRetrieves a specific SilverLining.config value as a double. \fP"
.ti -1c
.RI "void \fBUpdateEphemeris\fP ()"
.br
.RI "\fIForces the ephemeris model to recalculate the position of the sun, moon, and stars for the currently simulated time and location. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBSetRandomNumberGenerator\fP (const \fBRandomNumberGenerator\fP *rng)"
.br
.RI "\fIIf you wish to override SilverLining's default random number generator, which is based on the standard library's rand() function, you may do so by extending the \fBRandomNumberGenerator\fP base class, instantiating your extended class, and passing in a pointer to your class here. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This class is the main interface to SilverLining. 

The \fBAtmosphere\fP simulates the sky, clouds, and weather.
.PP
To use an \fBAtmosphere\fP class, simply instantiate one using the default constructor, and then call the \fBInitialize()\fP method to set it up for either the OpenGL or DirectX rendering subsystems.
.PP
You may initialize the atmospheric conditions (cloud decks, wind, time, location, etc.) by populating an \fBAtmosphericConditions\fP class and passing this to the SetConditions method prior to rendering.
.PP
Then, within your main rendering loop, as soon as you have set the view and projection matrices for your scene to reflect the current camera position, call the \fBBeginFrame()\fP method. This will draw the background of the sky and perform any lighting computations required for the atmosphere.
.PP
At this point, you may query \fBGetSunOrMoonPosition()\fP and \fBGetSunOrMoonColor()\fP to obtain the tone-mapped directional lighting information for your outdoor scene, and \fBGetAmbientColor()\fP to get the tone-mapped ambient skylight for your scene.
.PP
Finally, at the end of your rendering loop, call \fBEndFrame()\fP. This will draw all of the clouds within the scene in back-to-front order. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SilverLining::Atmosphere::Atmosphere (const char * userName, const char * licenseKey)"
.PP
Constructor. 
.PP
Creates an atmosphere object with default settings. You must specify the user name and license key provided with your SilverLining license purchase in order to instantiate an \fBAtmosphere\fP. An invalid name / key combination will result in a dialog box informing the user that this software is unlicensed, and in the application terminating after two minutes of use.
.PP
Warning! Displaying a dialog box while in full-screen mode will cause some DirectX applications to crash. To prevent the licensing dialog box on unlicensed SDK's from causing a crash, instantiate your \fBAtmosphere\fP object before entering full-screen mode.
.PP
\fBParameters:\fP
.RS 4
\fIuserName\fP The user name, exactly as provided to you in the licensing information received with your SilverLining license purchase. A null-terminated C string. 
.br
\fIlicenseKey\fP The license key code, exactly as provided to you with your license purchase. Null-terminated C string. 
.RE
.PP

.SS "SilverLining::Atmosphere::~Atmosphere ()"
.PP
Destructor. 
.PP
This will clean up all cloud objects owned by the atmospheric conditions. 
.SH "Member Function Documentation"
.PP 
.SS "bool SilverLining::Atmosphere::BeginFrame (bool drawSky, bool geocentricMode = \fCfalse\fP, double skyBoxDimension = \fC0\fP)"
.PP
Call this at the beginning of your rendering loop. 
.PP
At the start of each frame in your scene, first call \fBSetCameraMatrix()\fP and \fBSetProjectionMatrix()\fP. Then, call \fBBeginFrame()\fP. This will draw the skybox for the simulated time and location, including the sun, moon, stars, and planets, and perform any necessary lighting calculations.
.PP
It is important that the camera and projection matrices are set to reflect your scene's current camera prior to calling \fBBeginFrame()\fP. Versions of SilverLining prior to 1.7 would extract these matrices automatically, but beginning with 1.7 you MUST call \fBSetCameraMatrix()\fP and \fBSetProjectionMatrix()\fP. We made this change in order to support DirectX 10, which has no fixed function pipeline for us to query for these matrices.
.PP
\fBParameters:\fP
.RS 4
\fIdrawSky\fP Pass false to suppress drawing of the skybox, but still perform any lighting calculations required. 
.br
\fIgeocentricMode\fP If set to true, the stars, planets, sun, and moon will be drawn in a geocentric coordinate frame, where the X axis points through the prime meridian, Z points through the North Pole, and the origin is at the center of the Earth. This is generally only useful for space-based viewpoints. Normally, you'll leave this set to false so that astronomical objects will be drawn in local horizon coordinates. 
.br
\fIskyBoxDimension\fP Sets an explicit dimension in world units for the length of a face of the sky box. Useful to prevent clipping of the skybox in systems that dynamically adjust the near and far clip planes; you can specify a value each frame that fits within them. Most applications can just leave this set to 0, in which case it will draw the sky box with the default size specified in SilverLining.config (1000) 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the skybox was successfully drawn. 
.RE
.PP

.SS "void SilverLining::Atmosphere::DrawObject (ObjectHandle obj)"
.PP
If you are managing your own cloud object drawing by calling EndFrame(false), then your sorted list of objects may drawn by calling \fBDrawObject()\fP on each object. 
.PP
Your rendering state must be set for rendering translucent objects. Specifically, you must enable blending with a blend equation of ONE, INVSRCALPHA. Lighting must be off, depth reads enabled, depth writes disabled, fog must be off, and 2D texturing enabled.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP An object handle obtained from the list returned by \fBGetObjects()\fP, after calling EndFrame(false).
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEndFrame()\fP 
.PP
\fBGetObjects()\fP 
.PP
\fBGetObjectDistance()\fP 
.RE
.PP

.SS "bool SilverLining::Atmosphere::EndFrame (bool drawClouds = \fCtrue\fP)"
.PP
Call this at the end of your rendering loop. 
.PP
After drawing all of your scene's objects, call the \fBEndFrame()\fP method. This will draw all of the scene's clouds from back to front, if the drawClouds parameter is set to true. If there are translucent objects in your scene that should be drawn in front of the clouds, you'll want to draw those after calling \fBEndFrame()\fP.
.PP
Alternately, you may obtain handles to each cloud object independently and sort them with the other translucent objects in your scene. If you set drawClouds to false, \fBEndFrame()\fP will build up a list of translucent objects to render for this frame, but not actually render them. You may then access each individual cloud object with the \fBGetObjects()\fP method, sort them against your other translucent objects using the \fBGetObjectDistance()\fP method to obtain their sort distances, and then actually draw them using \fBDrawObject()\fP.
.PP
For applications where the scene is generally beneath the clouds, setting drawClouds to true and then drawing your own translucent objects after \fBEndFrame()\fP is generally adequate.
.PP
\fBParameters:\fP
.RS 4
\fIdrawClouds\fP Set to true if you want EndFrame to actually draw all of the clouds, sorted from back to front. Set to false if you just want to build up a list of clouds to draw but not actually draw them; this list may be obtained with \fBGetObjects()\fP.
.RE
.PP
\fBReturns:\fP
.RS 4
true if the clouds were successfully drawn. 
.RE
.PP

.SS "void SilverLining::Atmosphere::ForceLightingRecompute ()\fC [inline]\fP"
.PP
Force SilverLining to recompute all cloud lighting. 
.PP
Under normal operation, SilverLining only recomputes cloud lighting when the simulated time, location, or cloud cover changes, or when the camera moves a significant amount relative to each cloud. If you wish to force a lighting computation for all clouds to take place on the next frame, call this method.
.PP
There is a performance impact for calling this. Under normal circumstances, there is no reason to call this method. 
.SS "void SilverLining::Atmosphere::GetAmbientColor (float * r, float * g, float * b) const"
.PP
Returns the color of the ambient 'skylight'. 
.PP
This color is suitable for use as an ambient light color for your scene. When used together with the directional light position and color returned by GetSunOrMoonPosition and GetSunOrMoonColor, an accurate simulated model of natural lighting conditions may be obtained.
.PP
The color returned by this method is arrived at by simulating the light scattered over the sky above your simulated location at your simulated time, commonly referred to as 'skylight.' This light is then tone-mapped to account for high dynamic range in the same manner as the directional light. This color is also affected by the presence of thick cloud decks above the camera position.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A pointer to a float to receive the red channel of the ambient color, from 0 -1.0. 
.br
\fIg\fP A pointer to a float to receive the green channel of the ambient color, from 0 -1.0. 
.br
\fIb\fP A pointer to a float to receive the blue channel of the ambient color, from 0 -1.0. 
.RE
.PP

.SS "\fBAtmosphericConditions\fP* SilverLining::Atmosphere::GetConditions ()\fC [inline]\fP"
.PP
Return a reference to the current simulated conditions. 
.PP
Use this to change the current simulated time, location, etc., by manipulating the \fBAtmosphericConditions\fP object owned by the \fBAtmosphere\fP class directly. 
.SS "const \fBAtmosphericConditions\fP& SilverLining::Atmosphere::GetConditions () const"
.PP
Accessor to the current cloud, wind, time, and location settings. 
.PP
Returns a const reference to an \fBAtmosphericConditions\fP class that contains the settings for the current simulation. 
.SS "bool SilverLining::Atmosphere::GetConfigOptionBoolean (const char * key) const"
.PP
Retrieves a specific SilverLining.config value as a double. 
.PP

.SS "double SilverLining::Atmosphere::GetConfigOptionDouble (const char * key) const"
.PP
Retrieves a specific SilverLining.config value as a double. 
.PP

.SS "const char* SilverLining::Atmosphere::GetConfigOptionString (const char * key) const"
.PP
Retrieves a specific SilverLining.config value as a string. 
.PP

.SS "bool SilverLining::Atmosphere::GetFogEnabled () const"
.PP
Returns whether SilverLining would like to suggest fog settings. 
.PP
SilverLining depends on fog effects to simulate being inside a stratus or broken stratus cloud deck, or to simulate reduced visibility due to the presence of rain or snow at the camera's location. If this method returns true, then you should call GetFogSettings in order to help determine the appropriate fog configuration for your scene in order to preserve these atmospheric effects. 
.SS "void SilverLining::Atmosphere::GetFogSettings (float * density, float * r, float * g, float * b) const"
.PP
Returns exponential fog settings appropriate for your scene. 
.PP
If \fBGetFogEnabled()\fP returns true, then call \fBGetFogSettings()\fP to obtain suggested fog values required to preserve in-cloud effects and precipitation effects that depend on fog. The r, g, and b colors returned are the color of the fog itself modulated by the directional light color.
.PP
\fBParameters:\fP
.RS 4
\fIdensity\fP A fog density appropriate for use in GL_FOG_DENSITY in exponential fog mode. ie, $f = e^{-(density \cdot z)}$ 
.br
\fIr\fP A pointer to a float to receive the red component of the fog color, from 0 - 1.0. 
.br
\fIg\fP A pointer to a float to receive the green component of the fog color, from 0 - 1.0. 
.br
\fIb\fP A pointer to a float to receive the blue component of the fog color, from 0 - 1.0. 
.RE
.PP

.SS "double SilverLining::Atmosphere::GetFramerate () const\fC [inline]\fP"
.PP
Return the current framerate, based on the rendering time of the previous frame, in frames per second. 
.PP

.SS "double SilverLining::Atmosphere::GetGamma () const"
.PP
Retrieves the value being used for display gamma correction. 
.PP
\fBSee also:\fP
.RS 4
\fBSetGamma()\fP 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetHaze (float & hazeR, float & hazeG, float & hazeB, double & hazeDepth, double & hazeDensity)"
.PP
Retrieves the haze parameters set previously by \fBSetHaze()\fP. 
.PP
See \fBSetHaze()\fP for a description of the parameters. 
.SS "void SilverLining::Atmosphere::GetHorizonColor (float * r, float * g, float * b) const"
.PP
Returns the average color of the sky at the horizon. 
.PP
Based on the current camera orientation and field of view, this method will return the average color of the sky in the scene at the horizon. This is often an effective choice of a fog color for your scenes, since it will blend well with the sky in the distance - thereby covering up outdoor scenes that lack sufficient terrain to extend to the horizon. Even for scenes that do render to the horizon, this is a good color for fog just for simulating haze and atmospheric perspective.
.PP
Note that during sunrise and sunset when a red glow surround the sun, this color may vary widely depending on the orientation of the camera.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.br
\fIg\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.br
\fIb\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetHorizonColor (float yawDegrees, float * r, float * g, float * b) const"
.PP
Returns the average color of the sky at the horizon. 
.PP
Based on the specified view direction and field of view, this method will return the average color of the sky in the scene at the horizon. This is often an effective choice of a fog color for your scenes, since it will blend well with the sky in the distance - thereby covering up outdoor scenes that lack sufficient terrain to extend to the horizon. Even for scenes that do render to the horizon, this is a good color for fog just for simulating haze and atmospheric perspective.
.PP
Note that during sunrise and sunset when a red glow surround the sun, this color may vary widely depending on the yawDegrees parameter.
.PP
\fBParameters:\fP
.RS 4
\fIyawDegrees\fP The camera's yaw value, in degrees east from north. The horizon color will be calculated by averaging the field of view's horizon color about this direction. 
.br
\fIr\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.br
\fIg\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.br
\fIb\fP A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetMoonColor (float * r, float * g, float * b) const"
.PP
Returns the color of the moon's light source. 
.PP
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. For example, at night it may be suprisingly bright if a full moon is out. This scattering is sensitive to the turbidity setting specified in the \fBAtmosphericConditions\fP class.
.PP
This method only simulates natural light sources passing through the atmosphere: the sun, moon, starlight, planetary light, airglow, galactic light, and zodiacal light. At night, it may be appropriate to add in a little extra to simulate city lights for urban or suburban scenes.
.PP
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. 
.br
\fIg\fP A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. 
.br
\fIb\fP A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetMoonPosition (float * x, float * y, float * z) const"
.PP
Retrieve the normalized direction of the moon's light source. 
.PP
This method will return a normalized direction vector pointing to the moon, which may be below the horizon. 
.SS "void SilverLining::Atmosphere::GetMoonPositionEquatorial (float * x, float * y, float * z) const"
.PP
Retrieve the direction of the moon in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
.PP

.SS "void SilverLining::Atmosphere::GetMoonPositionGeographic (float * x, float * y, float * z) const"
.PP
Retrieve the direction of the moon, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
.PP

.SS "float SilverLining::Atmosphere::GetObjectDistance (ObjectHandle obj, ObjectHandle obj2, float sortPosX, float sortPosY, float sortPosZ)"
.PP
If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. 
.PP
This method will return the distance from a given position you are sorting from to the object in question.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP An object handle obtained from the list returned by \fBGetObjects()\fP, after calling EndFrame(false). 
.br
\fIobj2\fP The object you are comparing this object against. 
.br
\fIsortPosX\fP The X coordinate of the viewpoint location you are sorting translucent objects against. 
.br
\fIsortPosY\fP The Y coordinate of the viewpoint location you are sorting translucent objects against. 
.br
\fIsortPosZ\fP The Z coordinate of the viewpoint location you are sorting translucent objects against. 
.RE
.PP
\fBReturns:\fP
.RS 4
The distance to the object from the sort position specified, taking into account internal depth biases.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEndFrame()\fP 
.PP
\fBDrawObject()\fP 
.PP
\fBGetObjects()\fP 
.RE
.PP

.SS "float SilverLining::Atmosphere::GetObjectDistance (ObjectHandle obj, float obj2X, float obj2Y, float obj2Z, float sortPosX, float sortPosY, float sortPosZ)"
.PP
If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. 
.PP
This method will return the distance from a given position you are sorting from to the object in question.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP An object handle obtained from the list returned by \fBGetObjects()\fP, after calling EndFrame(false). 
.br
\fIobj2X\fP The X coordinate of the object you are currently comparing this one against. 
.br
\fIobj2Y\fP The Y coordinate of the object you are currently comparing this one against. 
.br
\fIobj2Z\fP The Z coordinate of the object you are currently comparing this one against. 
.br
\fIsortPosX\fP The X coordinate of the viewpoint location you are sorting translucent objects against. 
.br
\fIsortPosY\fP The Y coordinate of the viewpoint location you are sorting translucent objects against. 
.br
\fIsortPosZ\fP The Z coordinate of the viewpoint location you are sorting translucent objects against. 
.RE
.PP
\fBReturns:\fP
.RS 4
The distance to the object from the sort position specified, taking into account internal depth biases.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEndFrame()\fP 
.PP
\fBDrawObject()\fP 
.PP
\fBGetObjects()\fP 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetObjectPosition (ObjectHandle obj, float & x, float & y, float & z)"
.PP
Obtains the position, in world coordinates, of a given ObjectHandle obtained from the list returned from \fBGetObjects()\fP. 
.PP

.SS "std::vector<ObjectHandle>& SilverLining::Atmosphere::GetObjects () const"
.PP
If you called \fBEndFrame()\fP with the drawClouds parameter set to false, no clouds will actually be drawn. 
.PP
It's then your responsibility to obtain a list of cloud objects to draw, and draw them yourself. \fBGetObjects()\fP provides you with this list. This list will be empty until \fBEndFrame()\fP has been called for the current frame. If you call \fBEndFrame()\fP with the drawClouds parameter set to true, this list will also be empty, since the objects have already been drawn.
.PP
\fBSee also:\fP
.RS 4
\fBEndFrame()\fP 
.PP
\fBGetObjectDistance()\fP 
.PP
\fBDrawObject()\fP 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetRightVector (double & x, double & y, double & z)"
.PP
Returns the direction that SilverLining assumes is 'right' as a unit vector. 
.PP

.SS "void SilverLining::Atmosphere::GetSunColor (float * r, float * g, float * b) const"
.PP
Returns the color of the sun's light source. 
.PP
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. At sunset or sunrise, there may be an orange, pink, or reddish hue due to the scattering of sunlight through the atmosphere - which is also simulated. This scattering is sensitive to the turbidity setting specified in the \fBAtmosphericConditions\fP class.
.PP
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. 
.br
\fIg\fP A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. 
.br
\fIb\fP A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetSunOrMoonColor (float * r, float * g, float * b) const"
.PP
Returns the color of the dominant directional light source. 
.PP
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. For example, at noon this value is likely white, but at night it may be suprisingly bright if a full moon is out. At sunset or sunrise, there may be an orange, pink, or reddish hue due to the scattering of sunlight through the atmosphere - which is also simulated. This scattering is sensitive to the turbidity setting specified in the \fBAtmosphericConditions\fP class.
.PP
This method only simulates natural light sources passing through the atmosphere: the sun, moon, starlight, planetary light, airglow, galactic light, and zodiacal light. At night, it may be appropriate to add in a little extra to simulate city lights for urban or suburban scenes.
.PP
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. 
.br
\fIg\fP A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. 
.br
\fIb\fP A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. 
.RE
.PP

.SS "void SilverLining::Atmosphere::GetSunOrMoonPosition (float * x, float * y, float * z) const"
.PP
Retrieve the normalized direction of the dominant directional light source. 
.PP
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. 
.SS "void SilverLining::Atmosphere::GetSunOrMoonPositionEquatorial (float * x, float * y, float * z) const"
.PP
Retrieve the normalized direction of the dominant directional light source. 
.PP
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. The direction is in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
.SS "void SilverLining::Atmosphere::GetSunOrMoonPositionGeographic (float * x, float * y, float * z) const"
.PP
Retrieve the normalized direction of the dominant directional light source. 
.PP
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. The direction is relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
.SS "void SilverLining::Atmosphere::GetSunPosition (float * x, float * y, float * z) const"
.PP
Retrieve the normalized direction of the sun's light source. 
.PP
This method will return a normalized direction vector pointing to the sun, which may be below the horizon. 
.SS "void SilverLining::Atmosphere::GetSunPositionEquatorial (float * x, float * y, float * z) const"
.PP
Retrieve the direction of the sun in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
.PP

.SS "void SilverLining::Atmosphere::GetSunPositionGeographic (float * x, float * y, float * z) const"
.PP
Retrieve the direction of the sun, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
.PP

.SS "void SilverLining::Atmosphere::GetUpVector (double & x, double & y, double & z)"
.PP
Returns the direction that SilverLining assumes is 'up' as a unit vector. 
.PP

.SS "int SilverLining::Atmosphere::Initialize (int renderer, const char * resourceDirectoryPath, bool rightHanded, void * environment)"
.PP
Call this immediately after constructing your scene's \fBAtmosphere\fP and initializing your graphics subsystem (OpenGL, DirectX9, or DirectX10). 
.PP
This method will configure SilverLining to use OpenGL or DirectX, and in the case of DirectX, allows you to pass in a required pointer to your IDirect3DDevice9 or ID3D10Device object.
.PP
Note, DirectX 9 users must create their IDirect3DDevice9 using the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag. SilverLining depends on the ability to read back a small number of pixels from the back buffer when it computes its lighting effects. Passing in a device without a lockable back buffer will result in black clouds. You also must NOT create your device with the D3DCREATE_PUREDEVICE flag; SilverLining must be able to read your current render states and transforms in order to restore them to what they were when we finish our own drawing.
.PP
OpenGL users may pass 0 for the environment parameter. It is ignored for OpenGL.
.PP
You must also pass in a path to the Resources directory, which contains the art resources, data files, and shaders required for SilverLining to run. You may name and redistribute this directory however you wish, but SilverLining needs to know where it is and what it's called.
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP Pass the enumerated constant \fCSilverLining::OPENGL\fP or \fCSilverLining::DIRECTX9\fP or \fCSilverLining::DIRECTX10\fP 
.br
\fIresourceDirectoryPath\fP A null-terminated string that specifies a path to the application's redistributed 'Resources' directory, including the directory name itself and the trailing backslash. For example, '..\\\\Resources\\\\'. If you pass NULL, the default path is '.\\\\Resources'.
.br
\fIrightHanded\fP Pass true if you're using a right-handed coordinate system, false for a left-handed coordinate system. OpenGL typically uses right-handed; DirectX can use either.
.br
\fIenvironment\fP Only required for DIRECTX9 or DIRECTX10 renderers; a pointer to your IDirect3DDevice9 or ID3D10Device.
.RE
.PP
\fBReturns:\fP
.RS 4
An error code from the Atmosphere::InitializeErrors enumeration, or E_NOERROR. See the troubleshooting section of the documentation for further guidance if you encounter an error. 
.RE
.PP

.SS "void SilverLining::Atmosphere::ReloadConfigFile ()"
.PP
Reloads the SilverLining.config file in the resources directory. 
.PP
This won't immediately affect existing clouds in the scene, but will affect new clouds created going forward. Mostly this is useful for advanced users who want to tweak the default config file settings without having to shut down and restart their application every time. Requires that \fBAtmosphere::Initialize()\fP was called previously. 
.SS "void SilverLining::Atmosphere::SetCameraMatrix (double * cameraMatrix)"
.PP
Call this at the beginning of each rendering loop, prior to calling \fBBeginFrame()\fP. 
.PP
The matrix passed in should represent the transform for your camera, as a 4x4 matrix of doubles. Be sure to also call \fBSetProjectionMatrix()\fP 
.SS "void SilverLining::Atmosphere::SetConditions (const \fBAtmosphericConditions\fP & conditions)"
.PP
Configures the simulated cloud, wind, time, and location. 
.PP
The cloud, wind, time, and location settings are all contained inside an \fBAtmosphericConditions\fP object. Pass in an \fBAtmosphericConditions\fP class configured the way you like it, after first calling Initialize on the \fBAtmosphere\fP class, and before rendering your scene. Any previous conditions will be overwritten by this call.
.PP
Note, this passes in a const reference to your \fBAtmosphericConditions\fP class. It is copied internally, and you're free to dispose of your \fBAtmosphericConditions\fP object once you have passed it into SetConditions. 
.SS "void SilverLining::Atmosphere::SetConfigOption (const char * key, const char * value)"
.PP
Sets a specific SilverLining.config value. 
.PP
Will overwrite whatever was specified. Subject to the same caveats listed for \fBReloadConfigFile()\fP. 
.SS "void SilverLining::Atmosphere::SetGamma (double gamma)"
.PP
Sets the value used for gamma correction of the display. 
.PP
Defaults to the sky-box-gamma setting. 1.8 works well. Higher values will yield lighter skies and natural light. 
.SS "void SilverLining::Atmosphere::SetHaze (float hazeR, float hazeG, float hazeB, double hazeDepth, double hazeDensity)"
.PP
Causes the sky to blend toward a specified 'haze color' toward the horizon. 
.PP
Although it does simulate a layer of colored fog, it's most practical application to allow for exact blending against a fog color used for terrain, in order to obscure the horizon line. For applications that do not render terrain all the way to the horizon, this is a must. \fBGetHorizonColor()\fP may be used for an approximate match in the absence of an artificial layer of haze; it is more physically accurate.
.PP
The haze color passed in is not lit; you must pre-multiply the color yourself. The skybox will blend toward the exact color passed in at the horizon, night or day. You could abuse this to create a glow effect at the horizon from city lights, for example.
.PP
By default, hazeDepth is set to 0, thereby disabling the haze effects. If the viewpoint is within a cloud, the fog effects from the cloud will drawn in the sky in lieu of haze.
.PP
\fBParameters:\fP
.RS 4
\fIhazeR\fP The red component of the color to blend toward at the horizon. 
.br
\fIhazeG\fP The red component of the color to blend toward at the horizon. 
.br
\fIhazeB\fP The red component of the color to blend toward at the horizon. 
.br
\fIhazeDepth\fP The simulated height of the haze volume at ground level, in world units. 
.br
\fIhazeDensity\fP The fog density parameter of the exponential fog equation. 
.RE
.PP

.SS "void SilverLining::Atmosphere::SetProjectionMatrix (double * projectionMatrix)"
.PP
Call this at the beginning of each rendering loop, prior to calling \fBBeginFrame()\fP. 
.PP
The matrix passed in should represent the projection matrix for your scene, as a 4x4 matrix of doubles. Be sure to also call \fBSetCameraMatrix()\fP 
.SS "static void SilverLining::Atmosphere::SetRandomNumberGenerator (const \fBRandomNumberGenerator\fP * rng)\fC [static]\fP"
.PP
If you wish to override SilverLining's default random number generator, which is based on the standard library's rand() function, you may do so by extending the \fBRandomNumberGenerator\fP base class, instantiating your extended class, and passing in a pointer to your class here. 
.PP
Your class will be deleted along with the \fBAtmosphere\fP object. 
.SS "void SilverLining::Atmosphere::SetRightVector (double x, double y, double z)"
.PP
Sets the assumption of what direction is 'right'. 
.PP
Defaults to (1, 0, 0) if unset. If the vector (x, y, z) is not a unit vector, it is normalized before being stored. Cannot be called prior to \fBAtmosphere::Initialize()\fP. Must be called in conjunction with \fBSetUpVector()\fP.
.PP
If you're not using a default right vector, be sure to call this prior to positioning any clouds.
.PP
\fBSee also:\fP
.RS 4
\fBSetUpVector()\fP 
.PP
\fBGetRightVector()\fP 
.RE
.PP

.SS "void SilverLining::Atmosphere::SetUpVector (double x, double y, double z)"
.PP
Sets the assumption of what direction is 'up'. 
.PP
Defaults to (0, 1, 0) if unset. If the vector (x, y, z) is not a unit vector, it is normalized before being stored. Cannot be called prior to \fBAtmosphere::Initialize()\fP. Must be called in conjunction with \fBSetRightVector()\fP.
.PP
If you're not using a default Up vector, be sure to call this prior to positioning any clouds.
.PP
\fBSee also:\fP
.RS 4
\fBSetRightVector()\fP 
.PP
\fBGetUpVector()\fP 
.RE
.PP

.SS "void SilverLining::Atmosphere::ShowFramerate (bool framerateOn)\fC [inline]\fP"
.PP
Display the framerate in the bottom right of the viewport. 
.PP
Call to enable or disable a display of the framerate, in frames per second, in the bottom right hand corner of the screen. Note, this is disabled in the DirectX 9 renderer due to compatibility problems. The framerate displayed is a moving average over 300 frames. 
.SS "void SilverLining::Atmosphere::UpdateEphemeris ()"
.PP
Forces the ephemeris model to recalculate the position of the sun, moon, and stars for the currently simulated time and location. 
.PP
This happens automatically when \fBBeginFrame()\fP is called; this is provided only if you need to compute the astronomical positions in response to a change in the simulated time and location prior to calling \fBBeginFrame()\fP. 

.SH "Author"
.PP 
Generated automatically by Doxygen for SilverLining from the source code.
