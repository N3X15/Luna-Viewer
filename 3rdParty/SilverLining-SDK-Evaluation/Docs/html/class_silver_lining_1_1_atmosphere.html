<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SilverLining: SilverLining::Atmosphere Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>SilverLining</b>::<a class="el" href="class_silver_lining_1_1_atmosphere.html">Atmosphere</a>
  </div>
</div>
<div class="contents">
<h1>SilverLining::Atmosphere Class Reference</h1><!-- doxytag: class="SilverLining::Atmosphere" -->This class is the main interface to SilverLining.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Atmosphere.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for SilverLining::Atmosphere:</div>
<div class="dynsection">
<p><center><img src="class_silver_lining_1_1_atmosphere__coll__graph.png" border="0" usemap="#_silver_lining_1_1_atmosphere__coll__map" alt="Collaboration graph"></center>
<map name="_silver_lining_1_1_atmosphere__coll__map">
<area shape="rect" href="class_silver_lining_1_1_random_number_generator.html" title="Extend this class in order to use your own random number generator with SilverLining..." alt="" coords="5,119,288,145"><area shape="rect" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky." alt="" coords="312,119,571,145"><area shape="rect" href="class_silver_lining_1_1_local_time.html" title="A class to represent the simulated local time, time zone, and daylight savings time..." alt="" coords="163,7,336,33"><area shape="rect" href="class_silver_lining_1_1_location.html" title="An object representing a geographic location." alt="" coords="360,7,523,33"><area shape="rect" href="class_silver_lining_1_1_millisecond_timer.html" title="Exposes an interface to allow applications to control millisecond&#45;level time." alt="" coords="547,7,763,33"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_silver_lining_1_1_atmosphere-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#e745c3a0b2cb4e6d1f13c8845a58732c">Atmosphere</a> (const char *userName, const char *licenseKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#e745c3a0b2cb4e6d1f13c8845a58732c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#ed06ce8edc73dccdb13ab1bc04431a09">~Atmosphere</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ed06ce8edc73dccdb13ab1bc04431a09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0de336018b35e4614c62c347bae6fd78"></a><!-- doxytag: member="SilverLining::Atmosphere::GetVersionNumber" ref="0de336018b35e4614c62c347bae6fd78" args="() const " -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#0de336018b35e4614c62c347bae6fd78">GetVersionNumber</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the version number of SilverLining (ie, 1.0). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#dec1fd122175fd49439720fdc6084d60">SetConditions</a> (const <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a> &amp;conditions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the simulated cloud, wind, time, and location.  <a href="#dec1fd122175fd49439720fdc6084d60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#7b0ac4f0ec8a2d2d6bec75744644fb71">GetConditions</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor to the current cloud, wind, time, and location settings.  <a href="#7b0ac4f0ec8a2d2d6bec75744644fb71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#362efc03580e40bde60590db1ed39de1">GetSunOrMoonPosition</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the normalized direction of the dominant directional light source.  <a href="#362efc03580e40bde60590db1ed39de1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#1bdd8c7288efc6938bc9549d4276043f">GetSunOrMoonPositionGeographic</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the normalized direction of the dominant directional light source.  <a href="#1bdd8c7288efc6938bc9549d4276043f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#743684a1fee731308aa7fbece4f4fd2e">GetSunOrMoonPositionEquatorial</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the normalized direction of the dominant directional light source.  <a href="#743684a1fee731308aa7fbece4f4fd2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#557365e6787672b8cac57fbb584070c6">GetSunPosition</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the normalized direction of the sun's light source.  <a href="#557365e6787672b8cac57fbb584070c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#210cd7b4dda761985f2083a42c1dc35b">GetMoonPosition</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the normalized direction of the moon's light source.  <a href="#210cd7b4dda761985f2083a42c1dc35b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#884815625095af2713ffddfdaf68efce">GetSunPositionGeographic</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the direction of the sun, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian.  <a href="#884815625095af2713ffddfdaf68efce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#b80256ee385943bac7c753446af7e4a4">GetMoonPositionGeographic</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the direction of the moon, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian.  <a href="#b80256ee385943bac7c753446af7e4a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#cc0fd583e15a61587d60f2b83ccf491f">GetSunPositionEquatorial</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the direction of the sun in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole.  <a href="#cc0fd583e15a61587d60f2b83ccf491f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#2747159d2ac588a74d8a1ec077b34c5b">GetMoonPositionEquatorial</a> (float *x, float *y, float *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the direction of the moon in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole.  <a href="#2747159d2ac588a74d8a1ec077b34c5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#4ccd5fbbff1147d91dda5df141c43eb4">GetSunOrMoonColor</a> (float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the color of the dominant directional light source.  <a href="#4ccd5fbbff1147d91dda5df141c43eb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#12828675bb8491d2b6b4c40ac3022432">GetSunColor</a> (float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the color of the sun's light source.  <a href="#12828675bb8491d2b6b4c40ac3022432"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#17ffccd382288bba8e326fd8b4fec770">GetMoonColor</a> (float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the color of the moon's light source.  <a href="#17ffccd382288bba8e326fd8b4fec770"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#a20f511c889983917905014b6538982b">GetAmbientColor</a> (float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the color of the ambient "skylight".  <a href="#a20f511c889983917905014b6538982b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#aa10356ddeb7066602b1cd74deb27195">GetHorizonColor</a> (float yawDegrees, float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the average color of the sky at the horizon.  <a href="#aa10356ddeb7066602b1cd74deb27195"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#60e6add6ab96ed273b168f7ec54b1dfa">GetHorizonColor</a> (float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the average color of the sky at the horizon.  <a href="#60e6add6ab96ed273b168f7ec54b1dfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#d675ecef142f4272bb0d79872ebeff26">GetFogEnabled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether SilverLining would like to suggest fog settings.  <a href="#d675ecef142f4272bb0d79872ebeff26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#1f674bc10b7008fb7604cad3c6a9e22b">GetFogSettings</a> (float *density, float *r, float *g, float *b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns exponential fog settings appropriate for your scene.  <a href="#1f674bc10b7008fb7604cad3c6a9e22b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#dee37093f61d1d2d1f9d96e69cf3a846">SetHaze</a> (float hazeR, float hazeG, float hazeB, double hazeDepth, double hazeDensity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Causes the sky to blend toward a specified "haze color" toward the horizon.  <a href="#dee37093f61d1d2d1f9d96e69cf3a846"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#d428701acd6eaf3148e539b9df65da81">GetHaze</a> (float &amp;hazeR, float &amp;hazeG, float &amp;hazeB, double &amp;hazeDepth, double &amp;hazeDensity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the haze parameters set previously by <a class="el" href="class_silver_lining_1_1_atmosphere.html#dee37093f61d1d2d1f9d96e69cf3a846" title="Causes the sky to blend toward a specified &quot;haze color&quot; toward the horizon...">SetHaze()</a>.  <a href="#d428701acd6eaf3148e539b9df65da81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#a4896d88a1274f9fd4b1cccff5978f21">SetGamma</a> (double gamma)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value used for gamma correction of the display.  <a href="#a4896d88a1274f9fd4b1cccff5978f21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#0d3d45679e44ae21b1427581443756c2">GetGamma</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the value being used for display gamma correction.  <a href="#0d3d45679e44ae21b1427581443756c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#9b5d9a16e0a67691656219df6b90d600">ForceLightingRecompute</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force SilverLining to recompute all cloud lighting.  <a href="#9b5d9a16e0a67691656219df6b90d600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#8dc73acfe2dd96aa4f6e371b53625092">GetConditions</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the current simulated conditions.  <a href="#8dc73acfe2dd96aa4f6e371b53625092"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#e4702e18e119e6a0aa949e1edcb3d399">Initialize</a> (int renderer, const char *resourceDirectoryPath, bool rightHanded, void *environment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this immediately after constructing your scene's <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> and initializing your graphics subsystem (OpenGL, DirectX9, or DirectX10).  <a href="#e4702e18e119e6a0aa949e1edcb3d399"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#3658e218b90c5f62275dca5e4f65e28b">SetUpVector</a> (double x, double y, double z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the assumption of what direction is "up".  <a href="#3658e218b90c5f62275dca5e4f65e28b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#e2769f066c8c923a6895740e6b325759">GetUpVector</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the direction that SilverLining assumes is "up" as a unit vector.  <a href="#e2769f066c8c923a6895740e6b325759"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#bf58360333f6bed154287502e5d04b59">SetRightVector</a> (double x, double y, double z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the assumption of what direction is "right".  <a href="#bf58360333f6bed154287502e5d04b59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#9c45c2c8b9fe7459b8f60f20ad96af1a">GetRightVector</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the direction that SilverLining assumes is "right" as a unit vector.  <a href="#9c45c2c8b9fe7459b8f60f20ad96af1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#78945ec24881cb51c5de08f8603cd9ae">SetCameraMatrix</a> (double *cameraMatrix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this at the beginning of each rendering loop, prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>.  <a href="#78945ec24881cb51c5de08f8603cd9ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#2486ff4cf16c8689ddb8ab19cabb5374">SetProjectionMatrix</a> (double *projectionMatrix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this at the beginning of each rendering loop, prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>.  <a href="#2486ff4cf16c8689ddb8ab19cabb5374"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367">BeginFrame</a> (bool drawSky, bool geocentricMode=false, double skyBoxDimension=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this at the beginning of your rendering loop.  <a href="#f67f1584532b77ce006a49c148fa7367"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0">EndFrame</a> (bool drawClouds=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this at the end of your rendering loop.  <a href="#4b2597762e5987c95e1b397ab1cc23d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#084374a0850a322b024b49f7d5156154">ShowFramerate</a> (bool framerateOn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display the framerate in the bottom right of the viewport.  <a href="#084374a0850a322b024b49f7d5156154"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#d94e76b922b2c70c013dd560aba92d76">GetFramerate</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current framerate, based on the rendering time of the previous frame, in frames per second.  <a href="#d94e76b922b2c70c013dd560aba92d76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; ObjectHandle &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77">GetObjects</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you called <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> with the drawClouds parameter set to false, no clouds will actually be drawn.  <a href="#fed9c51029bb7e16186fcbf399598b77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#86d3895f6fedf43e2762c796b4a05462">GetObjectDistance</a> (ObjectHandle obj, float obj2X, float obj2Y, float obj2Z, float sortPosX, float sortPosY, float sortPosZ)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene.  <a href="#86d3895f6fedf43e2762c796b4a05462"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#942d0218bbaef6433c026392db9c772f">GetObjectDistance</a> (ObjectHandle obj, ObjectHandle obj2, float sortPosX, float sortPosY, float sortPosZ)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene.  <a href="#942d0218bbaef6433c026392db9c772f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#0477a11ac90bcc61d3719443a5a6fd1c">GetObjectPosition</a> (ObjectHandle obj, float &amp;x, float &amp;y, float &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the position, in world coordinates, of a given ObjectHandle obtained from the list returned from <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>.  <a href="#0477a11ac90bcc61d3719443a5a6fd1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba">DrawObject</a> (ObjectHandle obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you are managing your own cloud object drawing by calling EndFrame(false), then your sorted list of objects may drawn by calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a> on each object.  <a href="#d70bc1b5d08c01360b81994be3d826ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#c70986ad49b84fef2cf4dd7bea9aef60">ReloadConfigFile</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reloads the SilverLining.config file in the resources directory.  <a href="#c70986ad49b84fef2cf4dd7bea9aef60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#9bc7f8af7e0d8a158ee431b502f562c9">SetConfigOption</a> (const char *key, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific SilverLining.config value.  <a href="#9bc7f8af7e0d8a158ee431b502f562c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#8db433470a4720645517d3966a60041b">GetConfigOptionString</a> (const char *key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a specific SilverLining.config value as a string.  <a href="#8db433470a4720645517d3966a60041b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#0c90abc62d6c45c4545a0b20e171ec6f">GetConfigOptionDouble</a> (const char *key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a specific SilverLining.config value as a double.  <a href="#0c90abc62d6c45c4545a0b20e171ec6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#3859f9b9fe1e1cd1c4c06a648ae8e393">GetConfigOptionBoolean</a> (const char *key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a specific SilverLining.config value as a double.  <a href="#3859f9b9fe1e1cd1c4c06a648ae8e393"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#6513e3a4fa8f87b8d0774beeff373d36">UpdateEphemeris</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the ephemeris model to recalculate the position of the sun, moon, and stars for the currently simulated time and location.  <a href="#6513e3a4fa8f87b8d0774beeff373d36"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_silver_lining_1_1_atmosphere.html#673e5a91882d0610d8fadcc45f73835f">SetRandomNumberGenerator</a> (const <a class="el" href="class_silver_lining_1_1_random_number_generator.html">RandomNumberGenerator</a> *rng)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you wish to override SilverLining's default random number generator, which is based on the standard library's rand() function, you may do so by extending the <a class="el" href="class_silver_lining_1_1_random_number_generator.html" title="Extend this class in order to use your own random number generator with SilverLining...">RandomNumberGenerator</a> base class, instantiating your extended class, and passing in a pointer to your class here.  <a href="#673e5a91882d0610d8fadcc45f73835f"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class is the main interface to SilverLining. 
<p>
The <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> simulates the sky, clouds, and weather.<p>
To use an <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> class, simply instantiate one using the default constructor, and then call the <a class="el" href="class_silver_lining_1_1_atmosphere.html#e4702e18e119e6a0aa949e1edcb3d399" title="Call this immediately after constructing your scene&#39;s Atmosphere and initializing...">Initialize()</a> method to set it up for either the OpenGL or DirectX rendering subsystems.<p>
You may initialize the atmospheric conditions (cloud decks, wind, time, location, etc.) by populating an <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class and passing this to the SetConditions method prior to rendering.<p>
Then, within your main rendering loop, as soon as you have set the view and projection matrices for your scene to reflect the current camera position, call the <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a> method. This will draw the background of the sky and perform any lighting computations required for the atmosphere.<p>
At this point, you may query <a class="el" href="class_silver_lining_1_1_atmosphere.html#362efc03580e40bde60590db1ed39de1" title="Retrieve the normalized direction of the dominant directional light source.">GetSunOrMoonPosition()</a> and <a class="el" href="class_silver_lining_1_1_atmosphere.html#4ccd5fbbff1147d91dda5df141c43eb4" title="Returns the color of the dominant directional light source.">GetSunOrMoonColor()</a> to obtain the tone-mapped directional lighting information for your outdoor scene, and <a class="el" href="class_silver_lining_1_1_atmosphere.html#a20f511c889983917905014b6538982b" title="Returns the color of the ambient &quot;skylight&quot;.">GetAmbientColor()</a> to get the tone-mapped ambient skylight for your scene.<p>
Finally, at the end of your rendering loop, call <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a>. This will draw all of the clouds within the scene in back-to-front order. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e745c3a0b2cb4e6d1f13c8845a58732c"></a><!-- doxytag: member="SilverLining::Atmosphere::Atmosphere" ref="e745c3a0b2cb4e6d1f13c8845a58732c" args="(const char *userName, const char *licenseKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SilverLining::Atmosphere::Atmosphere           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>userName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>licenseKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
Creates an atmosphere object with default settings. You must specify the user name and license key provided with your SilverLining license purchase in order to instantiate an <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a>. An invalid name / key combination will result in a dialog box informing the user that this software is unlicensed, and in the application terminating after two minutes of use.<p>
Warning! Displaying a dialog box while in full-screen mode will cause some DirectX applications to crash. To prevent the licensing dialog box on unlicensed SDK's from causing a crash, instantiate your <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> object before entering full-screen mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>userName</em>&nbsp;</td><td>The user name, exactly as provided to you in the licensing information received with your SilverLining license purchase. A null-terminated C string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>licenseKey</em>&nbsp;</td><td>The license key code, exactly as provided to you with your license purchase. Null-terminated C string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed06ce8edc73dccdb13ab1bc04431a09"></a><!-- doxytag: member="SilverLining::Atmosphere::~Atmosphere" ref="ed06ce8edc73dccdb13ab1bc04431a09" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SilverLining::Atmosphere::~Atmosphere           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
This will clean up all cloud objects owned by the atmospheric conditions. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f67f1584532b77ce006a49c148fa7367"></a><!-- doxytag: member="SilverLining::Atmosphere::BeginFrame" ref="f67f1584532b77ce006a49c148fa7367" args="(bool drawSky, bool geocentricMode=false, double skyBoxDimension=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SilverLining::Atmosphere::BeginFrame           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawSky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>geocentricMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>skyBoxDimension</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this at the beginning of your rendering loop. 
<p>
At the start of each frame in your scene, first call <a class="el" href="class_silver_lining_1_1_atmosphere.html#78945ec24881cb51c5de08f8603cd9ae" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetCameraMatrix()</a> and <a class="el" href="class_silver_lining_1_1_atmosphere.html#2486ff4cf16c8689ddb8ab19cabb5374" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetProjectionMatrix()</a>. Then, call <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>. This will draw the skybox for the simulated time and location, including the sun, moon, stars, and planets, and perform any necessary lighting calculations.<p>
It is important that the camera and projection matrices are set to reflect your scene's current camera prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>. Versions of SilverLining prior to 1.7 would extract these matrices automatically, but beginning with 1.7 you MUST call <a class="el" href="class_silver_lining_1_1_atmosphere.html#78945ec24881cb51c5de08f8603cd9ae" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetCameraMatrix()</a> and <a class="el" href="class_silver_lining_1_1_atmosphere.html#2486ff4cf16c8689ddb8ab19cabb5374" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetProjectionMatrix()</a>. We made this change in order to support DirectX 10, which has no fixed function pipeline for us to query for these matrices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>drawSky</em>&nbsp;</td><td>Pass false to suppress drawing of the skybox, but still perform any lighting calculations required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geocentricMode</em>&nbsp;</td><td>If set to true, the stars, planets, sun, and moon will be drawn in a geocentric coordinate frame, where the X axis points through the prime meridian, Z points through the North Pole, and the origin is at the center of the Earth. This is generally only useful for space-based viewpoints. Normally, you'll leave this set to false so that astronomical objects will be drawn in local horizon coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>skyBoxDimension</em>&nbsp;</td><td>Sets an explicit dimension in world units for the length of a face of the sky box. Useful to prevent clipping of the skybox in systems that dynamically adjust the near and far clip planes; you can specify a value each frame that fits within them. Most applications can just leave this set to 0, in which case it will draw the sky box with the default size specified in SilverLining.config (1000) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the skybox was successfully drawn. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d70bc1b5d08c01360b81994be3d826ba"></a><!-- doxytag: member="SilverLining::Atmosphere::DrawObject" ref="d70bc1b5d08c01360b81994be3d826ba" args="(ObjectHandle obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::DrawObject           </td>
          <td>(</td>
          <td class="paramtype">ObjectHandle&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you are managing your own cloud object drawing by calling EndFrame(false), then your sorted list of objects may drawn by calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a> on each object. 
<p>
Your rendering state must be set for rendering translucent objects. Specifically, you must enable blending with a blend equation of ONE, INVSRCALPHA. Lighting must be off, depth reads enabled, depth writes disabled, fog must be off, and 2D texturing enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>An object handle obtained from the list returned by <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>, after calling EndFrame(false).</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#86d3895f6fedf43e2762c796b4a05462" title="If you are managing your own cloud drawing, you&#39;ll need to sort them from back...">GetObjectDistance()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b2597762e5987c95e1b397ab1cc23d0"></a><!-- doxytag: member="SilverLining::Atmosphere::EndFrame" ref="4b2597762e5987c95e1b397ab1cc23d0" args="(bool drawClouds=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SilverLining::Atmosphere::EndFrame           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawClouds</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this at the end of your rendering loop. 
<p>
After drawing all of your scene's objects, call the <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> method. This will draw all of the scene's clouds from back to front, if the drawClouds parameter is set to true. If there are translucent objects in your scene that should be drawn in front of the clouds, you'll want to draw those after calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a>.<p>
Alternately, you may obtain handles to each cloud object independently and sort them with the other translucent objects in your scene. If you set drawClouds to false, <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> will build up a list of translucent objects to render for this frame, but not actually render them. You may then access each individual cloud object with the <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a> method, sort them against your other translucent objects using the <a class="el" href="class_silver_lining_1_1_atmosphere.html#86d3895f6fedf43e2762c796b4a05462" title="If you are managing your own cloud drawing, you&#39;ll need to sort them from back...">GetObjectDistance()</a> method to obtain their sort distances, and then actually draw them using <a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a>.<p>
For applications where the scene is generally beneath the clouds, setting drawClouds to true and then drawing your own translucent objects after <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> is generally adequate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>drawClouds</em>&nbsp;</td><td>Set to true if you want EndFrame to actually draw all of the clouds, sorted from back to front. Set to false if you just want to build up a list of clouds to draw but not actually draw them; this list may be obtained with <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the clouds were successfully drawn. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b5d9a16e0a67691656219df6b90d600"></a><!-- doxytag: member="SilverLining::Atmosphere::ForceLightingRecompute" ref="9b5d9a16e0a67691656219df6b90d600" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::ForceLightingRecompute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Force SilverLining to recompute all cloud lighting. 
<p>
Under normal operation, SilverLining only recomputes cloud lighting when the simulated time, location, or cloud cover changes, or when the camera moves a significant amount relative to each cloud. If you wish to force a lighting computation for all clouds to take place on the next frame, call this method.<p>
There is a performance impact for calling this. Under normal circumstances, there is no reason to call this method. 
</div>
</div><p>
<a class="anchor" name="a20f511c889983917905014b6538982b"></a><!-- doxytag: member="SilverLining::Atmosphere::GetAmbientColor" ref="a20f511c889983917905014b6538982b" args="(float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetAmbientColor           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the color of the ambient "skylight". 
<p>
This color is suitable for use as an ambient light color for your scene. When used together with the directional light position and color returned by GetSunOrMoonPosition and GetSunOrMoonColor, an accurate simulated model of natural lighting conditions may be obtained.<p>
The color returned by this method is arrived at by simulating the light scattered over the sky above your simulated location at your simulated time, commonly referred to as "skylight." This light is then tone-mapped to account for high dynamic range in the same manner as the directional light. This color is also affected by the presence of thick cloud decks above the camera position.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the ambient color, from 0 -1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float to receive the green channel of the ambient color, from 0 -1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float to receive the blue channel of the ambient color, from 0 -1.0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8dc73acfe2dd96aa4f6e371b53625092"></a><!-- doxytag: member="SilverLining::Atmosphere::GetConditions" ref="8dc73acfe2dd96aa4f6e371b53625092" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a>* SilverLining::Atmosphere::GetConditions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the current simulated conditions. 
<p>
Use this to change the current simulated time, location, etc., by manipulating the <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> object owned by the <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> class directly. 
</div>
</div><p>
<a class="anchor" name="7b0ac4f0ec8a2d2d6bec75744644fb71"></a><!-- doxytag: member="SilverLining::Atmosphere::GetConditions" ref="7b0ac4f0ec8a2d2d6bec75744644fb71" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a>&amp; SilverLining::Atmosphere::GetConditions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor to the current cloud, wind, time, and location settings. 
<p>
Returns a const reference to an <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class that contains the settings for the current simulation. 
</div>
</div><p>
<a class="anchor" name="3859f9b9fe1e1cd1c4c06a648ae8e393"></a><!-- doxytag: member="SilverLining::Atmosphere::GetConfigOptionBoolean" ref="3859f9b9fe1e1cd1c4c06a648ae8e393" args="(const char *key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SilverLining::Atmosphere::GetConfigOptionBoolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a specific SilverLining.config value as a double. 
<p>

</div>
</div><p>
<a class="anchor" name="0c90abc62d6c45c4545a0b20e171ec6f"></a><!-- doxytag: member="SilverLining::Atmosphere::GetConfigOptionDouble" ref="0c90abc62d6c45c4545a0b20e171ec6f" args="(const char *key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SilverLining::Atmosphere::GetConfigOptionDouble           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a specific SilverLining.config value as a double. 
<p>

</div>
</div><p>
<a class="anchor" name="8db433470a4720645517d3966a60041b"></a><!-- doxytag: member="SilverLining::Atmosphere::GetConfigOptionString" ref="8db433470a4720645517d3966a60041b" args="(const char *key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* SilverLining::Atmosphere::GetConfigOptionString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a specific SilverLining.config value as a string. 
<p>

</div>
</div><p>
<a class="anchor" name="d675ecef142f4272bb0d79872ebeff26"></a><!-- doxytag: member="SilverLining::Atmosphere::GetFogEnabled" ref="d675ecef142f4272bb0d79872ebeff26" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SilverLining::Atmosphere::GetFogEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether SilverLining would like to suggest fog settings. 
<p>
SilverLining depends on fog effects to simulate being inside a stratus or broken stratus cloud deck, or to simulate reduced visibility due to the presence of rain or snow at the camera's location. If this method returns true, then you should call GetFogSettings in order to help determine the appropriate fog configuration for your scene in order to preserve these atmospheric effects. 
</div>
</div><p>
<a class="anchor" name="1f674bc10b7008fb7604cad3c6a9e22b"></a><!-- doxytag: member="SilverLining::Atmosphere::GetFogSettings" ref="1f674bc10b7008fb7604cad3c6a9e22b" args="(float *density, float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetFogSettings           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns exponential fog settings appropriate for your scene. 
<p>
If <a class="el" href="class_silver_lining_1_1_atmosphere.html#d675ecef142f4272bb0d79872ebeff26" title="Returns whether SilverLining would like to suggest fog settings.">GetFogEnabled()</a> returns true, then call <a class="el" href="class_silver_lining_1_1_atmosphere.html#1f674bc10b7008fb7604cad3c6a9e22b" title="Returns exponential fog settings appropriate for your scene.">GetFogSettings()</a> to obtain suggested fog values required to preserve in-cloud effects and precipitation effects that depend on fog. The r, g, and b colors returned are the color of the fog itself modulated by the directional light color.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>density</em>&nbsp;</td><td>A fog density appropriate for use in GL_FOG_DENSITY in exponential fog mode. ie, <img class="formulaInl" alt="$f = e^{-(density \cdot z)}$" src="form_0.png"> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float to receive the red component of the fog color, from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float to receive the green component of the fog color, from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float to receive the blue component of the fog color, from 0 - 1.0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d94e76b922b2c70c013dd560aba92d76"></a><!-- doxytag: member="SilverLining::Atmosphere::GetFramerate" ref="d94e76b922b2c70c013dd560aba92d76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SilverLining::Atmosphere::GetFramerate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current framerate, based on the rendering time of the previous frame, in frames per second. 
<p>

</div>
</div><p>
<a class="anchor" name="0d3d45679e44ae21b1427581443756c2"></a><!-- doxytag: member="SilverLining::Atmosphere::GetGamma" ref="0d3d45679e44ae21b1427581443756c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SilverLining::Atmosphere::GetGamma           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the value being used for display gamma correction. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#a4896d88a1274f9fd4b1cccff5978f21" title="Sets the value used for gamma correction of the display.">SetGamma()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d428701acd6eaf3148e539b9df65da81"></a><!-- doxytag: member="SilverLining::Atmosphere::GetHaze" ref="d428701acd6eaf3148e539b9df65da81" args="(float &amp;hazeR, float &amp;hazeG, float &amp;hazeB, double &amp;hazeDepth, double &amp;hazeDensity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetHaze           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>hazeR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>hazeG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>hazeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>hazeDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>hazeDensity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the haze parameters set previously by <a class="el" href="class_silver_lining_1_1_atmosphere.html#dee37093f61d1d2d1f9d96e69cf3a846" title="Causes the sky to blend toward a specified &quot;haze color&quot; toward the horizon...">SetHaze()</a>. 
<p>
See <a class="el" href="class_silver_lining_1_1_atmosphere.html#dee37093f61d1d2d1f9d96e69cf3a846" title="Causes the sky to blend toward a specified &quot;haze color&quot; toward the horizon...">SetHaze()</a> for a description of the parameters. 
</div>
</div><p>
<a class="anchor" name="60e6add6ab96ed273b168f7ec54b1dfa"></a><!-- doxytag: member="SilverLining::Atmosphere::GetHorizonColor" ref="60e6add6ab96ed273b168f7ec54b1dfa" args="(float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetHorizonColor           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the average color of the sky at the horizon. 
<p>
Based on the current camera orientation and field of view, this method will return the average color of the sky in the scene at the horizon. This is often an effective choice of a fog color for your scenes, since it will blend well with the sky in the distance - thereby covering up outdoor scenes that lack sufficient terrain to extend to the horizon. Even for scenes that do render to the horizon, this is a good color for fog just for simulating haze and atmospheric perspective.<p>
Note that during sunrise and sunset when a red glow surround the sun, this color may vary widely depending on the orientation of the camera.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa10356ddeb7066602b1cd74deb27195"></a><!-- doxytag: member="SilverLining::Atmosphere::GetHorizonColor" ref="aa10356ddeb7066602b1cd74deb27195" args="(float yawDegrees, float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetHorizonColor           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yawDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the average color of the sky at the horizon. 
<p>
Based on the specified view direction and field of view, this method will return the average color of the sky in the scene at the horizon. This is often an effective choice of a fog color for your scenes, since it will blend well with the sky in the distance - thereby covering up outdoor scenes that lack sufficient terrain to extend to the horizon. Even for scenes that do render to the horizon, this is a good color for fog just for simulating haze and atmospheric perspective.<p>
Note that during sunrise and sunset when a red glow surround the sun, this color may vary widely depending on the yawDegrees parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>yawDegrees</em>&nbsp;</td><td>The camera's yaw value, in degrees east from north. The horizon color will be calculated by averaging the field of view's horizon color about this direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float to receive the red channel of the horizon color, from 0 - 1.0 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="17ffccd382288bba8e326fd8b4fec770"></a><!-- doxytag: member="SilverLining::Atmosphere::GetMoonColor" ref="17ffccd382288bba8e326fd8b4fec770" args="(float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetMoonColor           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the color of the moon's light source. 
<p>
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. For example, at night it may be suprisingly bright if a full moon is out. This scattering is sensitive to the turbidity setting specified in the <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class.<p>
This method only simulates natural light sources passing through the atmosphere: the sun, moon, starlight, planetary light, airglow, galactic light, and zodiacal light. At night, it may be appropriate to add in a little extra to simulate city lights for urban or suburban scenes.<p>
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="210cd7b4dda761985f2083a42c1dc35b"></a><!-- doxytag: member="SilverLining::Atmosphere::GetMoonPosition" ref="210cd7b4dda761985f2083a42c1dc35b" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetMoonPosition           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the normalized direction of the moon's light source. 
<p>
This method will return a normalized direction vector pointing to the moon, which may be below the horizon. 
</div>
</div><p>
<a class="anchor" name="2747159d2ac588a74d8a1ec077b34c5b"></a><!-- doxytag: member="SilverLining::Atmosphere::GetMoonPositionEquatorial" ref="2747159d2ac588a74d8a1ec077b34c5b" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetMoonPositionEquatorial           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the direction of the moon in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
<p>

</div>
</div><p>
<a class="anchor" name="b80256ee385943bac7c753446af7e4a4"></a><!-- doxytag: member="SilverLining::Atmosphere::GetMoonPositionGeographic" ref="b80256ee385943bac7c753446af7e4a4" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetMoonPositionGeographic           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the direction of the moon, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
<p>

</div>
</div><p>
<a class="anchor" name="942d0218bbaef6433c026392db9c772f"></a><!-- doxytag: member="SilverLining::Atmosphere::GetObjectDistance" ref="942d0218bbaef6433c026392db9c772f" args="(ObjectHandle obj, ObjectHandle obj2, float sortPosX, float sortPosY, float sortPosZ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SilverLining::Atmosphere::GetObjectDistance           </td>
          <td>(</td>
          <td class="paramtype">ObjectHandle&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectHandle&nbsp;</td>
          <td class="paramname"> <em>obj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosZ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. 
<p>
This method will return the distance from a given position you are sorting from to the object in question.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>An object handle obtained from the list returned by <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>, after calling EndFrame(false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj2</em>&nbsp;</td><td>The object you are comparing this object against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosX</em>&nbsp;</td><td>The X coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosY</em>&nbsp;</td><td>The Y coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosZ</em>&nbsp;</td><td>The Z coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The distance to the object from the sort position specified, taking into account internal depth biases.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="86d3895f6fedf43e2762c796b4a05462"></a><!-- doxytag: member="SilverLining::Atmosphere::GetObjectDistance" ref="86d3895f6fedf43e2762c796b4a05462" args="(ObjectHandle obj, float obj2X, float obj2Y, float obj2Z, float sortPosX, float sortPosY, float sortPosZ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SilverLining::Atmosphere::GetObjectDistance           </td>
          <td>(</td>
          <td class="paramtype">ObjectHandle&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>obj2X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>obj2Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>obj2Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sortPosZ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you are managing your own cloud drawing, you'll need to sort them from back to front along with the other objects in your scene. 
<p>
This method will return the distance from a given position you are sorting from to the object in question.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>An object handle obtained from the list returned by <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>, after calling EndFrame(false). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj2X</em>&nbsp;</td><td>The X coordinate of the object you are currently comparing this one against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj2Y</em>&nbsp;</td><td>The Y coordinate of the object you are currently comparing this one against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj2Z</em>&nbsp;</td><td>The Z coordinate of the object you are currently comparing this one against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosX</em>&nbsp;</td><td>The X coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosY</em>&nbsp;</td><td>The Y coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sortPosZ</em>&nbsp;</td><td>The Z coordinate of the viewpoint location you are sorting translucent objects against. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The distance to the object from the sort position specified, taking into account internal depth biases.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0477a11ac90bcc61d3719443a5a6fd1c"></a><!-- doxytag: member="SilverLining::Atmosphere::GetObjectPosition" ref="0477a11ac90bcc61d3719443a5a6fd1c" args="(ObjectHandle obj, float &amp;x, float &amp;y, float &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetObjectPosition           </td>
          <td>(</td>
          <td class="paramtype">ObjectHandle&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains the position, in world coordinates, of a given ObjectHandle obtained from the list returned from <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="fed9c51029bb7e16186fcbf399598b77"></a><!-- doxytag: member="SilverLining::Atmosphere::GetObjects" ref="fed9c51029bb7e16186fcbf399598b77" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ObjectHandle&gt;&amp; SilverLining::Atmosphere::GetObjects           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you called <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> with the drawClouds parameter set to false, no clouds will actually be drawn. 
<p>
It's then your responsibility to obtain a list of cloud objects to draw, and draw them yourself. <a class="el" href="class_silver_lining_1_1_atmosphere.html#fed9c51029bb7e16186fcbf399598b77" title="If you called EndFrame() with the drawClouds parameter set to false, no clouds will...">GetObjects()</a> provides you with this list. This list will be empty until <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> has been called for the current frame. If you call <a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> with the drawClouds parameter set to true, this list will also be empty, since the objects have already been drawn.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#4b2597762e5987c95e1b397ab1cc23d0" title="Call this at the end of your rendering loop.">EndFrame()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#86d3895f6fedf43e2762c796b4a05462" title="If you are managing your own cloud drawing, you&#39;ll need to sort them from back...">GetObjectDistance()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#d70bc1b5d08c01360b81994be3d826ba" title="If you are managing your own cloud object drawing by calling EndFrame(false), then...">DrawObject()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c45c2c8b9fe7459b8f60f20ad96af1a"></a><!-- doxytag: member="SilverLining::Atmosphere::GetRightVector" ref="9c45c2c8b9fe7459b8f60f20ad96af1a" args="(double &amp;x, double &amp;y, double &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetRightVector           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the direction that SilverLining assumes is "right" as a unit vector. 
<p>

</div>
</div><p>
<a class="anchor" name="12828675bb8491d2b6b4c40ac3022432"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunColor" ref="12828675bb8491d2b6b4c40ac3022432" args="(float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunColor           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the color of the sun's light source. 
<p>
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. At sunset or sunrise, there may be an orange, pink, or reddish hue due to the scattering of sunlight through the atmosphere - which is also simulated. This scattering is sensitive to the turbidity setting specified in the <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class.<p>
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4ccd5fbbff1147d91dda5df141c43eb4"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunOrMoonColor" ref="4ccd5fbbff1147d91dda5df141c43eb4" args="(float *r, float *g, float *b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunOrMoonColor           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the color of the dominant directional light source. 
<p>
This method will return a color suitable for lighting your scene based on the natural lighting conditions. The value is tone-mapped, so the high dynamic range between night and day and they way the human eye perceives it is modeled. For example, at noon this value is likely white, but at night it may be suprisingly bright if a full moon is out. At sunset or sunrise, there may be an orange, pink, or reddish hue due to the scattering of sunlight through the atmosphere - which is also simulated. This scattering is sensitive to the turbidity setting specified in the <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class.<p>
This method only simulates natural light sources passing through the atmosphere: the sun, moon, starlight, planetary light, airglow, galactic light, and zodiacal light. At night, it may be appropriate to add in a little extra to simulate city lights for urban or suburban scenes.<p>
If your camera position is below a thick stratus cloud deck, the effects on lighting will be simulated as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A pointer to a float that will be populated with the red directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>A pointer to a float that will be populated with the green directional light color, ranging from 0 - 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A pointer to a float that will be populated with the blue directional light color, ranging from 0 - 1.0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="362efc03580e40bde60590db1ed39de1"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunOrMoonPosition" ref="362efc03580e40bde60590db1ed39de1" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunOrMoonPosition           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the normalized direction of the dominant directional light source. 
<p>
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. 
</div>
</div><p>
<a class="anchor" name="743684a1fee731308aa7fbece4f4fd2e"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunOrMoonPositionEquatorial" ref="743684a1fee731308aa7fbece4f4fd2e" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunOrMoonPositionEquatorial           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the normalized direction of the dominant directional light source. 
<p>
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. The direction is in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
</div>
</div><p>
<a class="anchor" name="1bdd8c7288efc6938bc9549d4276043f"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunOrMoonPositionGeographic" ref="1bdd8c7288efc6938bc9549d4276043f" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunOrMoonPositionGeographic           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the normalized direction of the dominant directional light source. 
<p>
This method will return a normalized direction vector pointing to the dominant light source, which may be the moon after sunset. The direction is relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
</div>
</div><p>
<a class="anchor" name="557365e6787672b8cac57fbb584070c6"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunPosition" ref="557365e6787672b8cac57fbb584070c6" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunPosition           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the normalized direction of the sun's light source. 
<p>
This method will return a normalized direction vector pointing to the sun, which may be below the horizon. 
</div>
</div><p>
<a class="anchor" name="cc0fd583e15a61587d60f2b83ccf491f"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunPositionEquatorial" ref="cc0fd583e15a61587d60f2b83ccf491f" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunPositionEquatorial           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the direction of the sun in equatorial coordinates; where x points toward the vernal equinox (where the equator and ecliptic intersect), z points through the north pole. 
<p>

</div>
</div><p>
<a class="anchor" name="884815625095af2713ffddfdaf68efce"></a><!-- doxytag: member="SilverLining::Atmosphere::GetSunPositionGeographic" ref="884815625095af2713ffddfdaf68efce" args="(float *x, float *y, float *z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetSunPositionGeographic           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the direction of the sun, relative to the center of the Earth in a geocentric coordinate system, where the z axis points from the center of the Earth to the North Pole, and x points toward the prime meridian. 
<p>

</div>
</div><p>
<a class="anchor" name="e2769f066c8c923a6895740e6b325759"></a><!-- doxytag: member="SilverLining::Atmosphere::GetUpVector" ref="e2769f066c8c923a6895740e6b325759" args="(double &amp;x, double &amp;y, double &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::GetUpVector           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the direction that SilverLining assumes is "up" as a unit vector. 
<p>

</div>
</div><p>
<a class="anchor" name="e4702e18e119e6a0aa949e1edcb3d399"></a><!-- doxytag: member="SilverLining::Atmosphere::Initialize" ref="e4702e18e119e6a0aa949e1edcb3d399" args="(int renderer, const char *resourceDirectoryPath, bool rightHanded, void *environment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SilverLining::Atmosphere::Initialize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>resourceDirectoryPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>rightHanded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>environment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this immediately after constructing your scene's <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> and initializing your graphics subsystem (OpenGL, DirectX9, or DirectX10). 
<p>
This method will configure SilverLining to use OpenGL or DirectX, and in the case of DirectX, allows you to pass in a required pointer to your IDirect3DDevice9 or ID3D10Device object.<p>
Note, DirectX 9 users must create their IDirect3DDevice9 using the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag. SilverLining depends on the ability to read back a small number of pixels from the back buffer when it computes its lighting effects. Passing in a device without a lockable back buffer will result in black clouds. You also must NOT create your device with the D3DCREATE_PUREDEVICE flag; SilverLining must be able to read your current render states and transforms in order to restore them to what they were when we finish our own drawing.<p>
OpenGL users may pass 0 for the environment parameter. It is ignored for OpenGL.<p>
You must also pass in a path to the Resources directory, which contains the art resources, data files, and shaders required for SilverLining to run. You may name and redistribute this directory however you wish, but SilverLining needs to know where it is and what it's called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>renderer</em>&nbsp;</td><td>Pass the enumerated constant <code>SilverLining::OPENGL</code> or <code>SilverLining::DIRECTX9</code> or <code>SilverLining::DIRECTX10</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resourceDirectoryPath</em>&nbsp;</td><td>A null-terminated string that specifies a path to the application's redistributed "Resources" directory, including the directory name itself and the trailing backslash. For example, "..\\Resources\\". If you pass NULL, the default path is ".\\Resources".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rightHanded</em>&nbsp;</td><td>Pass true if you're using a right-handed coordinate system, false for a left-handed coordinate system. OpenGL typically uses right-handed; DirectX can use either.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>environment</em>&nbsp;</td><td>Only required for DIRECTX9 or DIRECTX10 renderers; a pointer to your IDirect3DDevice9 or ID3D10Device.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code from the Atmosphere::InitializeErrors enumeration, or E_NOERROR. See the troubleshooting section of the documentation for further guidance if you encounter an error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c70986ad49b84fef2cf4dd7bea9aef60"></a><!-- doxytag: member="SilverLining::Atmosphere::ReloadConfigFile" ref="c70986ad49b84fef2cf4dd7bea9aef60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::ReloadConfigFile           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reloads the SilverLining.config file in the resources directory. 
<p>
This won't immediately affect existing clouds in the scene, but will affect new clouds created going forward. Mostly this is useful for advanced users who want to tweak the default config file settings without having to shut down and restart their application every time. Requires that <a class="el" href="class_silver_lining_1_1_atmosphere.html#e4702e18e119e6a0aa949e1edcb3d399" title="Call this immediately after constructing your scene&#39;s Atmosphere and initializing...">Atmosphere::Initialize()</a> was called previously. 
</div>
</div><p>
<a class="anchor" name="78945ec24881cb51c5de08f8603cd9ae"></a><!-- doxytag: member="SilverLining::Atmosphere::SetCameraMatrix" ref="78945ec24881cb51c5de08f8603cd9ae" args="(double *cameraMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetCameraMatrix           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>cameraMatrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this at the beginning of each rendering loop, prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>. 
<p>
The matrix passed in should represent the transform for your camera, as a 4x4 matrix of doubles. Be sure to also call <a class="el" href="class_silver_lining_1_1_atmosphere.html#2486ff4cf16c8689ddb8ab19cabb5374" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetProjectionMatrix()</a> 
</div>
</div><p>
<a class="anchor" name="dec1fd122175fd49439720fdc6084d60"></a><!-- doxytag: member="SilverLining::Atmosphere::SetConditions" ref="dec1fd122175fd49439720fdc6084d60" args="(const AtmosphericConditions &amp;conditions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetConditions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html">AtmosphericConditions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>conditions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures the simulated cloud, wind, time, and location. 
<p>
The cloud, wind, time, and location settings are all contained inside an <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> object. Pass in an <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class configured the way you like it, after first calling Initialize on the <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> class, and before rendering your scene. Any previous conditions will be overwritten by this call.<p>
Note, this passes in a const reference to your <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> class. It is copied internally, and you're free to dispose of your <a class="el" href="class_silver_lining_1_1_atmospheric_conditions.html" title="A class to set the current simulation conditions for the sky.">AtmosphericConditions</a> object once you have passed it into SetConditions. 
</div>
</div><p>
<a class="anchor" name="9bc7f8af7e0d8a158ee431b502f562c9"></a><!-- doxytag: member="SilverLining::Atmosphere::SetConfigOption" ref="9bc7f8af7e0d8a158ee431b502f562c9" args="(const char *key, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetConfigOption           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a specific SilverLining.config value. 
<p>
Will overwrite whatever was specified. Subject to the same caveats listed for <a class="el" href="class_silver_lining_1_1_atmosphere.html#c70986ad49b84fef2cf4dd7bea9aef60" title="Reloads the SilverLining.config file in the resources directory.">ReloadConfigFile()</a>. 
</div>
</div><p>
<a class="anchor" name="a4896d88a1274f9fd4b1cccff5978f21"></a><!-- doxytag: member="SilverLining::Atmosphere::SetGamma" ref="a4896d88a1274f9fd4b1cccff5978f21" args="(double gamma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetGamma           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gamma</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value used for gamma correction of the display. 
<p>
Defaults to the sky-box-gamma setting. 1.8 works well. Higher values will yield lighter skies and natural light. 
</div>
</div><p>
<a class="anchor" name="dee37093f61d1d2d1f9d96e69cf3a846"></a><!-- doxytag: member="SilverLining::Atmosphere::SetHaze" ref="dee37093f61d1d2d1f9d96e69cf3a846" args="(float hazeR, float hazeG, float hazeB, double hazeDepth, double hazeDensity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetHaze           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>hazeR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>hazeG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>hazeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>hazeDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>hazeDensity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the sky to blend toward a specified "haze color" toward the horizon. 
<p>
Although it does simulate a layer of colored fog, it's most practical application to allow for exact blending against a fog color used for terrain, in order to obscure the horizon line. For applications that do not render terrain all the way to the horizon, this is a must. <a class="el" href="class_silver_lining_1_1_atmosphere.html#aa10356ddeb7066602b1cd74deb27195" title="Returns the average color of the sky at the horizon.">GetHorizonColor()</a> may be used for an approximate match in the absence of an artificial layer of haze; it is more physically accurate.<p>
The haze color passed in is not lit; you must pre-multiply the color yourself. The skybox will blend toward the exact color passed in at the horizon, night or day. You could abuse this to create a glow effect at the horizon from city lights, for example.<p>
By default, hazeDepth is set to 0, thereby disabling the haze effects. If the viewpoint is within a cloud, the fog effects from the cloud will drawn in the sky in lieu of haze.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hazeR</em>&nbsp;</td><td>The red component of the color to blend toward at the horizon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hazeG</em>&nbsp;</td><td>The red component of the color to blend toward at the horizon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hazeB</em>&nbsp;</td><td>The red component of the color to blend toward at the horizon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hazeDepth</em>&nbsp;</td><td>The simulated height of the haze volume at ground level, in world units. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hazeDensity</em>&nbsp;</td><td>The fog density parameter of the exponential fog equation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2486ff4cf16c8689ddb8ab19cabb5374"></a><!-- doxytag: member="SilverLining::Atmosphere::SetProjectionMatrix" ref="2486ff4cf16c8689ddb8ab19cabb5374" args="(double *projectionMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetProjectionMatrix           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>projectionMatrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this at the beginning of each rendering loop, prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>. 
<p>
The matrix passed in should represent the projection matrix for your scene, as a 4x4 matrix of doubles. Be sure to also call <a class="el" href="class_silver_lining_1_1_atmosphere.html#78945ec24881cb51c5de08f8603cd9ae" title="Call this at the beginning of each rendering loop, prior to calling BeginFrame()...">SetCameraMatrix()</a> 
</div>
</div><p>
<a class="anchor" name="673e5a91882d0610d8fadcc45f73835f"></a><!-- doxytag: member="SilverLining::Atmosphere::SetRandomNumberGenerator" ref="673e5a91882d0610d8fadcc45f73835f" args="(const RandomNumberGenerator *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SilverLining::Atmosphere::SetRandomNumberGenerator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_silver_lining_1_1_random_number_generator.html">RandomNumberGenerator</a> *&nbsp;</td>
          <td class="paramname"> <em>rng</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you wish to override SilverLining's default random number generator, which is based on the standard library's rand() function, you may do so by extending the <a class="el" href="class_silver_lining_1_1_random_number_generator.html" title="Extend this class in order to use your own random number generator with SilverLining...">RandomNumberGenerator</a> base class, instantiating your extended class, and passing in a pointer to your class here. 
<p>
Your class will be deleted along with the <a class="el" href="class_silver_lining_1_1_atmosphere.html" title="This class is the main interface to SilverLining.">Atmosphere</a> object. 
</div>
</div><p>
<a class="anchor" name="bf58360333f6bed154287502e5d04b59"></a><!-- doxytag: member="SilverLining::Atmosphere::SetRightVector" ref="bf58360333f6bed154287502e5d04b59" args="(double x, double y, double z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetRightVector           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the assumption of what direction is "right". 
<p>
Defaults to (1, 0, 0) if unset. If the vector (x, y, z) is not a unit vector, it is normalized before being stored. Cannot be called prior to <a class="el" href="class_silver_lining_1_1_atmosphere.html#e4702e18e119e6a0aa949e1edcb3d399" title="Call this immediately after constructing your scene&#39;s Atmosphere and initializing...">Atmosphere::Initialize()</a>. Must be called in conjunction with <a class="el" href="class_silver_lining_1_1_atmosphere.html#3658e218b90c5f62275dca5e4f65e28b" title="Sets the assumption of what direction is &quot;up&quot;.">SetUpVector()</a>.<p>
If you're not using a default right vector, be sure to call this prior to positioning any clouds.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#3658e218b90c5f62275dca5e4f65e28b" title="Sets the assumption of what direction is &quot;up&quot;.">SetUpVector()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#9c45c2c8b9fe7459b8f60f20ad96af1a" title="Returns the direction that SilverLining assumes is &quot;right&quot; as a unit vector...">GetRightVector()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3658e218b90c5f62275dca5e4f65e28b"></a><!-- doxytag: member="SilverLining::Atmosphere::SetUpVector" ref="3658e218b90c5f62275dca5e4f65e28b" args="(double x, double y, double z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::SetUpVector           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the assumption of what direction is "up". 
<p>
Defaults to (0, 1, 0) if unset. If the vector (x, y, z) is not a unit vector, it is normalized before being stored. Cannot be called prior to <a class="el" href="class_silver_lining_1_1_atmosphere.html#e4702e18e119e6a0aa949e1edcb3d399" title="Call this immediately after constructing your scene&#39;s Atmosphere and initializing...">Atmosphere::Initialize()</a>. Must be called in conjunction with <a class="el" href="class_silver_lining_1_1_atmosphere.html#bf58360333f6bed154287502e5d04b59" title="Sets the assumption of what direction is &quot;right&quot;.">SetRightVector()</a>.<p>
If you're not using a default Up vector, be sure to call this prior to positioning any clouds.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_silver_lining_1_1_atmosphere.html#bf58360333f6bed154287502e5d04b59" title="Sets the assumption of what direction is &quot;right&quot;.">SetRightVector()</a> <p>
<a class="el" href="class_silver_lining_1_1_atmosphere.html#e2769f066c8c923a6895740e6b325759" title="Returns the direction that SilverLining assumes is &quot;up&quot; as a unit vector...">GetUpVector()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="084374a0850a322b024b49f7d5156154"></a><!-- doxytag: member="SilverLining::Atmosphere::ShowFramerate" ref="084374a0850a322b024b49f7d5156154" args="(bool framerateOn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::ShowFramerate           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>framerateOn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display the framerate in the bottom right of the viewport. 
<p>
Call to enable or disable a display of the framerate, in frames per second, in the bottom right hand corner of the screen. Note, this is disabled in the DirectX 9 renderer due to compatibility problems. The framerate displayed is a moving average over 300 frames. 
</div>
</div><p>
<a class="anchor" name="6513e3a4fa8f87b8d0774beeff373d36"></a><!-- doxytag: member="SilverLining::Atmosphere::UpdateEphemeris" ref="6513e3a4fa8f87b8d0774beeff373d36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SilverLining::Atmosphere::UpdateEphemeris           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the ephemeris model to recalculate the position of the sun, moon, and stars for the currently simulated time and location. 
<p>
This happens automatically when <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a> is called; this is provided only if you need to compute the astronomical positions in response to a change in the simulated time and location prior to calling <a class="el" href="class_silver_lining_1_1_atmosphere.html#f67f1584532b77ce006a49c148fa7367" title="Call this at the beginning of your rendering loop.">BeginFrame()</a>. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/home/fkane/sl/Public Headers/<a class="el" href="_atmosphere_8h.html">Atmosphere.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Sep 3 04:04:08 2009 for SilverLining by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
